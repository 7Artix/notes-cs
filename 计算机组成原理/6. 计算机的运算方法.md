
# 6.1 无符号数和有符号数

对于无符号数而言, 机器字长的每一位都用于存放数值.
对于有符号数而言, 需要留出存放符号的位置.
因此, 机器字长相同时, 无符号数和有符号数对应的数值范围是不同的.
例如机器字长为 16-bit 时
- 无符号数的表示范围为 `0 ~ 65535`
- 有符号数的表示范围为 `-32768 ~ +32767`


## 有符号数

### 机器数与真值

可以用 $0$ 表示 $正$ , 用 $1$ 表示 $负$ . 这样将符号数字化, 并规定将其放置于有效数字前, 组合成有符号数. 例如原码中:

有符号小数:
- `+0.1011` 表示为 `01011`
- `-0.1011` 表示为 `11011`
有符号整数:
- `+1100` 表示为 `01100`
- `-1100` 表示为 `11100`

将符号数字化的数称为<font color=red><b>机器数</b></font>, 将带有 `+/-` 号的数称为<font color=red><b>真值</b></font>.
为了能够使符号位和数值部分一起参与运算, 需要设计对应的编码.


### 原码

原码是机器数中最简单的表示形式, 符号位 $0$ 表示正数, $1$ 表示负数, 数值位即真值的绝对值.
原码又称为带符号的绝对值表示.
为了书写方便, 以及区分整数和小数, 约定整数的符号位与数值位之间用逗号隔开, 小数的符号位与数值位之间用小数点隔开, 例如上面 4 个数的源码分别为:
- `0.1011`
- `1.1011`
- `0,1100`
- `1,1100`

原码的详细定义如下.

整数原码定义为:

$$
[x]_{原} = 
\left\{
\begin{array}{ll}
0,x & 2^n>x\geq0\\
2^n-x & 0\geq x >-2^n
\end{array}
\right.
$$

其中, $x$ 为真值, $n$ 为整数的位数.
当为负数时, $2^n$ 实际是在原有数字前面的 $1$ , 而 $-x$ 就是 $+|x|$ .
需要注意使用 " $,$ " 将符号位与数值位分隔.

小数原码定义为:

$$
[x]_{原} = 
\left\{
\begin{array}{ll}
x & 1>x\geq0 \\
1-x & 0\geq x > -1
\end{array}
\right.
$$

其中, $x$ 为真值.

原码简单直观, 易于和真值转换. 但使用源码进行加减运算时, 却复杂繁琐. 
例如在做符号不同加法时, 需要判断两数绝对值大小, 然后做绝对值减法, 原本是加法运算, 却需要减法器实现. 
而设计目标是只在计算机中设加法器, 只做加法运算.


### 补码

例如 24 小时制的时钟, 若需要将 `6:00` 调至 `3:00` , 可以选择顺时针 `+9` 时, 或逆时针 `-3` 时. 结果一致, 分别对应:
- `06 + 09 = 15`
- `06 - 03 = 03`

再加上 $(\text{mod 12})$ 运算, 则 `+9` 和 `-3` 对于时钟作用相同.

称 $+9$ 是 $-3$ 以 $12$ 为模的补数, 记作:

$$
-3 \equiv +9 \quad (\text{mod 12})
$$

同理有:

$$
\begin{array}{}
-4 \equiv +8 \quad (\text{mod 12}) \\
-5 \equiv +7 \quad (\text{mod 12})
\end{array}
$$

因此, 确定 "模" 之后, 可以找到与负数等价的正数 (正数为该负数的补数) 来代替负数, 使减法可以由加法运算实现.

得出如下结论:
- 负数可用其正补数代替, 正补数可以用模加上负数本身计算
- 正数和负数互为补数时, 二者的和为模数
- 正数的补数是其本身

补码的详细定义如下.

整数的补码定义为:

$$
[x]_{原} = 
\left\{
\begin{array}{ll}
0,x & 2^n>x\geq0\\
2^{n+1}+x & 0\geq x >-2^n \quad (\text{mod }2^{n+1})
\end{array}
\right.
$$

其中, $x$ 为真值, $n$ 为整数的位数.
例如:
- `+1010` 的补码为 `0,1010`
- `-1101` 的补码为 `1,0011`

小数的补码定义为:

$$
[x]_{原} = 
\left\{
\begin{array}{ll}
x & 1>x\geq0 \\
2+x & 0 > x \geq -1 \quad (\text{mod }2)
\end{array}
\right.
$$

其中, $x$ 为真值.
例如:
- `+0.1001` 的补码为 `0.1001`
- `-0.0110` 的补码为 `10.0000 - 0.0110 = 1.1010`

补码的 `0` 唯一表示为 `0.0000` , 补码比源码多一种 `-1` 的表示: `1.0000` .

根据补码定义, 也可以用补码求真值:
- `1.0101` 的真值为 `1.0101 - 10.0000 = -0.1011`
- `1,1110` 的真值为 `1,1110 - 100000 = -0010`
- `0.1101` 的真值为 `0.1101`

补码的引入是为了消除减法运算, 但根据补码定义, 在形成补码的过程中仍然有减法.

但是本质上, 计算补码的过程就是一个凑模的过程, 例如求 `-1011` 的补码.

$$
[x]_补 = 2 ^ {4+1} + x = 100000 - 1011 = 1,0101
$$

观察 `1011` 和 `0101` 实际是对 `1011` 每位取反后 `+1` .

同理, 由补码求反码也可以通过取反加 1 实现.


### 反码

反码通常用来作为原码求补码, 或补码求原码的中间过渡. 反码的定义如下.

整数的反码定义为:

$$
[x]_{原} = 
\left\{
\begin{array}{ll}
0,x & 2^n>x\geq0\\
(2^{n+1}-1)+x & 0\geq x >-2^n \quad (\text{mod }(2^{n+1}-1))
\end{array}
\right.
$$

其中, $x$ 为真值, $n$ 为整数的位数.
例如:
- `+1101` 的反码为 `0,1101`
- `-1101` 的反码为 `1,0010`

小数的反码定义为:

$$
[x]_{原} = 
\left\{
\begin{array}{ll}
x & 1>x\geq0 \\
(2-2^{-n})+x & 0 > x \geq -1 \quad (\text{mod }(2-2^{-n}))
\end{array}
\right.
$$

其中, $x$ 为真值.
例如:
- `+0.0110` 的反码为 `0.0110`
- `-0.0110` 的反码为 `1.1111 - 0.0110 = 1.1001`

反码的 `0` 有两种表示: `0.0000` 和 `1.1111`

综上所述, 三种机器码的特点为:
- 最高位均为符号位, 符号位和数值位之间用 `.` 或 `,` 隔开.
- 当真值为正时, 原码, 补码, 反码相同.
- 当真值为负时, 补码是原码的<font color=red><b>求反加</b></font> $\color{red}1$ , 反码是原码的<font color=red><b>每位求反</b></font>.

使用 8 位空间, 可以存储的各类机器码的值表对应如下:

$$
\begin{array}{|c|c|}
\hline
二进制码 & 
\begin{array}{}{\color{red}无符号数}\\对应真值\end{array} & 
\begin{array}{}{\color{red}原码}\\对应真值\end{array} & 
\begin{array}{}{\color{red}补码}\\对应真值\end{array} & 
\begin{array}{}{\color{red}反码}\\对应真值\end{array} \\
\hline
00000000 & 0 & +0 & \pm0 & +0 \\
\hline
00000001 & 1 & +1 & +1 & +1 \\
\hline
00000010 & 2 & +2 & +2 & +2 \\
\hline
\vdots & \vdots & \vdots & \vdots & \vdots \\
\hline
01111110 & 126 & +126 & +126 & +126 \\
\hline
01111111 & 127 & +127 & +127 & +127 \\
\hline
10000000 & 128 & -0 & -128 & -127 \\
\hline
10000001 & 129 & -1 & -127 & -126 \\
\hline
10000010 & 130 & -2 & -126 & -125 \\
\hline
\vdots & \vdots & \vdots & \vdots & \vdots \\
\hline
11111101 & 253 & -125 & -3 & -2 \\
\hline
11111110 & 254 & -126 & -2 & -1 \\
\hline
11111111 & 255 & -127 & -1 & -0 \\
\hline
\end{array}
$$

补码比原码和反码可以多表示一个负数.

进一步分析补码的设计理念.

对于正数的表达上限 $+127$ , 若此时再加正数, 理论上便会出现数据溢出, 因此, 即使不考虑编码, 有符号数便不能再加正数.
而对于负数, 才是补码真正的应用领域.
$+127$ 的原码为 `01111111` , 假设以 $+127-1$ 的计算为例, 目标结果是 $+126$ , 原码为 `01111110` .
为了设计成减法也可以用加法计算, 必须找到一个加数 $x$ , 使 `01111111` $+x=$ `01111110` .
由于加法只能进位, 因此发现 `11111111` 可以满足条件, 相加后结果为 `101111110` , 多出了 HSB 处的 $1$ , 使用取模的方式将其去除.
取模是让结果等于预期的善后手段, 而不是目的.


### 移码

在数字和数字进行比较的过程中, 由于表示符号的符号位是 `0` 代表正数, `1` 代表负数. 
在比较两数大小的时候不够直观. 因此诞生了移码.

移码的定义为:

$$
[x]_移 = 2^n + x \quad (2^n>x\geq-2^n)
$$

移码就是在真值上加 $2^n$ .
例如:
- `+10100` 的移码为 `100000 + 10100 = 1,10100`
- `-10100` 的移码为 `100000 - 10100 = 0,01100`

移码就是将补码的符号位翻转而已.

移码的计算必须通过加减完成, 与 `<<` 或 `>>` 之类的逻辑左右移完全无关.

称之为移码, 只是由于移码是数学上的几何平移, 通过移码可以将负数完全偏移到正数区间内, 便于辨识.


# 6.2 数的定点表示和浮点表示

## 定点表示

小数点固定在某一位置的数为定点数.

定点数只能表示纯整数或纯小数, 格式分别为:
- <font color=red><b>纯整数</b></font>: `± 数值 .`
- <font color=red><b>纯小数</b></font>: `± . 数值`

早期计算机通常只能处理一种数格式的运算, 分为单独的整数定点机和小数定点机.
- 整数定点机: 倾向于通用计算和数据处理, 只能处理纯整数.
- 小数定点机: 倾向于金融, 科学等大量小数运算的领域, 只能处理纯小数.

由于定点机的小数点位置固定, 因此处理非纯小数或纯整数的时候, 需要乘以比例因子.


## 浮点表示

实际计算机中的数据不一定是纯小数或纯整数, 而且数值的范围相差很大, 有极大的数和极小的数需要同时处理.
浮点数, 即小数点位置可以浮动的数.
通常, 浮点数被表示为:

$$
N = S \times r^{j}
$$
- $S$ 为<font color=red><b>尾数</b></font>, 可正可负.
- $j$ 为<font color=red><b>阶码</b></font>, 可正可负.
- $r$ 为<font color=red><b>基数</b></font>.

在计算机中, 基数可取 $2,4,8,16$ 等.

以基数 $r=2$ 为例, $N$ 可以写作:

$$
\begin{align}{}
N & = 11.0101 \\
& = 11.0101 \times 2^0 \\
& = 1.10101 \times 2^1 \\
& = 0.110101 \times 2^{10} \\
& =0.00110101 \times 2^{100} \\
& = 1101.01 \times 2^{-10}
\end{align}
$$

计算机中规定尾数必须用<font color=red><b>纯小数</b></font>的形式.
将尾数最高位为 $1$ 的浮点数称为<font color=red><b>规格化数</b></font>.

浮点数的表示形式为:

$$
\overset{阶码}{\overbrace{
\underset{阶符}{\underbrace{\begin{array}{|c|}\hline j_f \\ \hline\end{array}}}
\underset{阶码数值部分}{\underbrace{\begin{array}{|c|}\hline j_1j_2\cdots j_m\\ \hline\end{array}}}
}}
\overset{尾数}{\overbrace{
\underset{数符}{\underbrace{\begin{array}{|c|}\hline S_f \\ \hline\end{array}}}
\underset{尾数数值部分}{\underbrace{\begin{array}{|c|}\hline S_1S_2\cdots S_n\\ \hline\end{array}}}
}}
$$

浮点数由阶码和尾数两部分组成. 
阶码是整数, 阶符和 $m$ 位阶码共同反映浮点数的表示范围, 以及小数点的实际位置.
尾数是小数, 其位数 $n$ 反映浮点数的精度, 尾数数符代表浮点数的正负.

浮点数的**表示范围**为:

$$
\begin{align}
&正数: \quad 2^{-(2^m-1)}\times2^{-n} \sim 2^{(2^m-1)}\times(1-2^{-n}) \\
&负数: \quad -2^{(2^m-1)}\times(1-2^{-n}) \sim -2^{-(2^m-1)}\times2^{-n}
\end{align}
$$

当浮点数阶码大于最大阶码, 称为<font color=red><b>上溢</b></font>, 通常进行中断溢出处理.
当浮点数阶码小于最小阶码, 称为<font color=red><b>下溢</b></font>, 通常直接将尾数置零.

浮点数位数确定后, 合理分配阶码和尾数的位数, 直接影响到浮点数的表示范围和精度. 通常对于: 
- 短实数 (32-bit)
  阶码取 8 bit, 尾数取 24 bit
- 长实数 (64-bit)
  阶码取 11 bit, 尾数取 53 bit
- 临时实数 (80-bit)
  阶码取 15 bit, 尾数取 65 bit


为了提升浮点数的精度, 尾数必须进行规格化.

基数为 $2$ 时:
尾数最高位为 $1$ 的数为规格化数. 规格化时: 
- 向左规格化: 尾数左移 $1$ 位, 阶码减 $1$ .
- 向右规格化: 尾数右移 $1$ 位, 阶码加 $1$ .

经过规格化后, 浮点数的表示范围为:

$$
\begin{align}
&正数: \quad 2^{-(2^m-1)}\times2^{-1} \sim 2^{(2^m-1)}\times(1-2^{-n}) \\
&负数: \quad -2^{(2^m-1)}\times(1-2^{-1}) \sim -2^{-(2^m-1)}\times2^{-n}
\end{align}
$$

基数为 $4$ 时:
尾数最高两位不全为零的数为规格化数. 规格化时: 
- 向左规格化: 尾数左移 $2$ 位, 阶码减 $1$ .
- 向右规格化: 尾数右移 $2$ 位, 阶码加 $1$ .

基数为 $8$ 时:
尾数最高三位不全为零的数为规格化数. 规格化时: 
- 向左规格化: 尾数左移 $3$ 位, 阶码减 $1$ .
- 向右规格化: 尾数右移 $3$ 位, 阶码加 $1$ .

## 规格化与非规格化

规格化的目的是获得**最高的有效数字精度**, 以及**唯一的表示方式**.

理解规格化与非规格化区别的重点在于<font color=red><b>表示范围</b></font>和<font color=red><b>精度</b></font>.
- 规格化: **提升精度, 损失范围**
- 非规格化: **提升范围, 损失精度**

浮点数的精度使用<font color=red><b>相对精度</b></font>衡量, 相对精度指数字能被精确到其自身大小的比例.
相对精度通常由尾数位决定, 尾数位越多, 相对精度越高.
对于规格化数而言, 其相对精度是固定的, 且是最高的.

以 23-bit 尾数域举例:

|      |                              最小规格化数                               |                              最大非规格化数                              |                              最小非规格化数                               |
| :--: | :---------------------------------------------------------------: | :---------------------------------------------------------------: | :----------------------------------------------------------------: |
|  形式  | $\underset{\text{23-bit}}{\underbrace{1.0\cdots0}}\times2^{-126}$ | $\underset{\text{23-bit}}{\underbrace{0.1\cdots1}}\times2^{-126}$ | $\underset{\text{23-bit}}{\underbrace{0.0\cdots01}}\times2^{-126}$ |
| 有效位数 |                        24-bit (1-bit 隐含位)                         |                              23-bit                               |                               1-bit                                |
| 相对精度 |                         最高 ( $2^{-23}$ )                          |                               接近最高                                |                                 最低                                 |

最小的规格化数 $\approx 1.175\times 10^{-38}$ 仍然拥有 24-bit 有效数字.
最小的非规格化数 $\approx1.4\times 10^{-45}$ 虽然更小, 但仅有 1-bit 有效数字.

非规格化牺牲了精度, 换取可以表示更接近 $0$ 的表示范围.
非规格化可以实现**渐进式下溢**, 填补了最小规格化数和 $0$ 之间的空隙, 使浮点数在接近 $0$ 时能够平滑过渡, 而不是**突然下溢**.

## 举例

> 将十进制数 $+\dfrac{13}{128}$ 改写, 浮点数字长 16-bit, 阶码 5-bit, 尾数 11-bit.

二进制形式为: `0.0001101`  
16-bit 字长定点数表示为: `0.000110100000000`  
在定点机中, $[x]_原 = [x]_{补} = [x]_反 =$ `0.000110100000000`  

其规格化表示为: $x=$ `0.1101` $\times 2^{-11}$  
浮点表示为:  
- 原码: `1,0011;0.1101000000`
- 补码: `1,1101;0.1101000000`
- 反码: `1,1100;0.1101000000`


> 将十进制数 $-54$ 改写, 浮点数字长 16-bit, 阶码 5-bit, 尾数 11-bit.

二进制形式为: `-110110`
定点表示为:
- 原码: `1,000000000110110`
- 补码: `1,111111111001010`
- 反码: `1,111111111001001`

其规格化表示为: `-0.11011` $\times 2^{110}$  
浮点表示为:
- 原码: `0,0110;1,1101100000`
- 补码: `0,0110;1,0010100000`
- 反码: `0,0110;1,0010011111`

注意, 纯整数补零向前补, 纯小数补零向后补.


## IEEE 754

IEEE二进制浮点数算术标准 (IEEE 754) 时最广泛使用的浮点数运算标准.
该标准定义了浮点数的格式, 反常值, 无穷, 非数值.
标准还定义了浮点数运算符, 4 种浮点数摄入规则, 5 种例外状况.

浮点数表示为:

$$
\text{Value} = \text{sign} \times \text{exponent} \times \text{fraction}
$$

即浮点数的实际值, 等于符号位, 乘以指数偏移值, 乘以分数值.

IEEE 754 的浮点数整体形式表现为:

$$
\begin{array}{|c|}
\hline
数符\\
\hline
\end{array}
\begin{array}{|c|}
\hline
指数部分(移码)\\
\hline
\end{array}
\begin{array}{|c|}
\hline
分数值(原码)\\
\hline
\end{array}
$$

小数点位于阶码和尾数之间, 数符提至 HSB 处.

分数值部分在非规格化表示时默认为 $0$ , 其余情况下全部默认为 $1$ .


### 指数偏移值 (Exponent Bias)

即浮点数表示法中指数域的编码值, 等于指数的实际值 + 某个固定值. IEEE 754 标准规定的固定值为 $2^{e-1}-1$ , 其中 $e$ 为存储指数的比特长度.

以单精度浮点数为例, 其指数域为 8-bit, 固定偏移值为 $2^{8-1}-1=127$ . 单精度浮点数的指数部分实际取值范围为 $-126\sim127$ , 另外的 $-127$ 和 $128$ 被用作特殊处理 (非规格化表示, 特殊值).

例如指数实际值为 $17_{10}$ , 则在单精度浮点数中的指数域编码值为 $17_{10}+127_{10}=144_{10}$ .

IEEE 754 的指数部分实际是一种特殊偏移量的移码.
移码的核心作用是将负数全部偏移到正数区间, 方便直观观察大小.

- $e=0$ 即全 $0$ 编码, 用于表示**非规格化数**和 $0$ .
- $e=255$ 即全 $1$ 编码, 用于表示无穷大 $\pm\infty$ 和非数 $\text{NaN}$ .


### 规约形式的浮点数

即规格化, 该表示下, 尾数有 1-bit 的隐含二进制有效数字, 称为有效数.


### 非规约形式的浮点数

即非规格化, 通常是在某个数字非常接近于 $0$ 时, 才会使用非规格化表示.
非规格化浮点数的指数偏移值比规格化的偏移值小 $1$ . 
例如在 8-bit 指数域的条件下:
- 最小规格化的单精度浮点指数部分编码值为 $1$ , 指数实际值为 $-126$ .
- 非规格化的单精度浮点指数部分编码值为 $0$ , 指数实际值也为 $-126$ .


### 特殊值

IEEE 754 的 3 种特殊值为:
- $\pm 0$ : 指数为 $0$ , 尾数的小数部分也为 $0$ , 即全 $0$ .
- $\pm\infty$ : 指数为 $2^{e}-1$ , 且尾数的小数部分为 $0$ . 正负取决于符号位.
- $\text{NaN}$ : 指数为 $2^{e}-1$ , 且尾数的小数部分为非零.


总结如下

$$
\begin{array}{|c|c|}
\hline
含义 & 指数 & 小数 \\
\hline
0 & 0 & 0 \\
\hline
非规约形式 & 0 & 大于0,小于1 \\
\hline
规约形式 & 1\sim 2^e-2 & 大于等于1, 小于2 \\
\hline
\pm\infty & 2^e-1 & 0 \\
\hline
\text{NaN} & 2^e-1 & 非0 \\
\hline
\end{array}
$$

注意, $2^e$ 与上文的 $2^{e-1}$ 不同, 此处为编码值, 而不是原始值.


# 6.3 定点运算

定点运算包括移位, 加, 减, 乘, 除.

## 移位运算

有符号数的移位称之为<font color=red><b>算数移位</b></font>, 无符号数的移位称之为<font color=red><b>逻辑移位</b></font>.

计算机中的小数点位置是事先约定的, 因此, 二进制表示的机器数进行 $n$ 位左移或右移时, 其本质为将原数乘以或除以 $2^n$ .

算数移位规则

符号位不随移位改变.

对于正数, $[x]_原 = [x]_补 = [x]_反 = 真值$ , 因此移位后出现的空位使用 $0$ 填充.
对于负数, 原码, 补码, 反码的表示形式不同, 因此移位后填补规则不同. 

$$
\begin{array}{|c|c|}
\hline
码制 & 填补规则 \\
\hline
原码 & 0 \\
\hline
补码 & 左移添0, \ 右移添1 \\
\hline
反码 & 1 \\
\hline
\end{array}
$$

观察补码可以发现, 对于从 LSB 到 HSB 方向上的第一个 $1$ : 
- 其左侧位数与反码相同
- 其右侧位数 (包括第一个 $1$ ) 与原码相同

例如:
- 原码: `1,1010100`
- 反码: `1,0101011`
- 补码: `1,0101100`

因此是 "左移添 $0$ , 右移添 $1$ " , 因为移位要与原码一致. 
- 左移时, 原码右侧添加了新 $0$ , 对应补码也应当添 $0$ .
- 右移时, 原码左侧添加了新 $0$ , 对应反码添加了新 $1$ , 对应补码也应当添 $1$ .

对于逻辑移位:
- 逻辑左移位时, 高位丢弃, 低位添 $0$ .
- 逻辑右移位时, 低位丢弃, 高位添 $0$ .

区别于算数移位, 对于逻辑移位, 首位的 $1$ 并不是代表负数的数符, 而是作为普通值处理.


### 桶形移位器

移位具体是通过<font color=red><b>桶型移位器</b></font> (barrel shifter) 的逻辑电路实现的. 桶形移位器非常高效, 可以在一个时钟周期内, 完成任意位数的移位操作.

构成移位器的基础元件为<font color=red><b>多路选择器</b></font> (Multiplexer, MUX) . 其基本功能为: 从多个输入信号中, 选择一个信号作为输出.

一个 $2^n$ 选 $1$ 的多路选择器由如下部分组成:

$$
\begin{array}{|c|c|}
\hline
名称 & 数量 & 作用 \\
\hline
数据输入端 (I_0,I_1,\cdots) & 2^n & 接受待选择的数据 \\
\hline
选择控制端 (S_0,S_1,\cdots) & n & 选择控制信号输入 \\
\hline
数据输出端 (Y) & 1 & 输出选择的数据 \\
\hline
\end{array}
$$

以 $2$ 选 $1$ MUX 为例:
有两个数据输入端 $I_0,I_1,\cdots$ , 和一个输出端 $S$ .
其真值表为:

$$
\begin{array}{|c|c|}
\hline
选择控制端(S) & 输出(Y) \\
\hline
0 & I_0 \\
\hline
1 & I_1 \\
\hline
\end{array}
$$

其布尔函数为:

$$
Y = \bar{S}\cdot I_0 + S\cdot I_1
$$

可以通过基本逻辑门实现.

移位操作的本质是将数据的每一位移动到新的位置. 可以使用 MUX 控制每一位数据时保持原位, 还是移动到其左边或右边的相邻位置.

以 $4$ 位数据的 $1$ 位循环左移移位器为例:
- 输入数据为: $D_3 D_2 D_1 D_0$
- 预期输出为: $D_2 D_1 D_0 D_3$

为此需要 4 个 $2$ 选 $1$ MUX, 每个 MUX 负责计算输出结果的 $1$ 位 $O_i$ .

$$
\begin{array}{|c|c|}
\hline
输出位(O_i) & \text{2选1 MUX功能} \\
\hline
O_0 & 选择 D_0或D_1\\
\hline
O_1 & 选择 D_1或D_2\\
\hline
O_2 & 选择 D_2或D_3\\
\hline
O_3 & 选择 D_3或D_0\\
\hline
\end{array}
$$

该逻辑电路可以使用一个控制信号 $S$ 进行控制:
- $S=0$ 保持, 输出 $O_i = D_i$
- $S=1$ 左移 $1$ 位, 输出 $O_i = D_{(i+1)(\text{mod 4})}$ 

实现任意 $N$ 位移位器, 需要使用分层级联结构.

若构建一个 $8$ 位移位器, 则需要 $n=\log_{2}8=3$ 个逻辑层.
1. 第 1 层 (1 位移位)
	- 功能: 实现 $0$ 位或 $1$ 位移位.
	- 控制: 移位控制信号 $S_0$ 控制.
	- 实现: 8 个 $2$ 选 $1$ MUX, 若 $S_0=1$ 则移 $1$ 位, 若 $S_0=0$ 则数据保持不动.
2. 第 2 层 (2 位移位)
	- 功能: 实现 $0$ 位或 $2$ 位移位.
	- 控制: 移位控制信号 $S_1$ 控制.
	- 实现: 8 个 $2$ 选 $1$ MUX, 以前一层的输出为输入, 若 $S_1=1$ 则再移 $2$ 位, 若 $S_1=0$ 则数据保持不动.
3. 第 3 层 (4 位移位)
	- 功能: 实现 $0$ 位或 $4$ 位移位.
	- 控制: 移位控制信号 $S_2$ 控制.
	- 实现: 8 个 $2$ 选 $1$ MUX, 以前一层的输出为输入, 若 $S_2=1$ 则再移 $4$ 位, 若 $S_1=0$ 则数据保持不动.


## 加减运算

减法可以看做加减数的负值, 因此加减合并讨论. 现代计算机中采用补码做加减运算.

补码加法运算的基本公式为:

$$
\begin{array}{ll}
整数: & [A]_补 + [B]_补 = [A+B]_补 (\text{mod }2^{n+1}) \\
小数: & [A]_补 + [B]_补 = [A+B]_补 (\text{mod }2)
\end{array}
$$

即整数计算后, 丢弃超出范围的位; 小数计算后, 丢弃整数部分超出符号位的位.

取模的过程是补码运算的核心. 使用补码的意义在于将减法推向和加法相同的叠加方向, 利用循环获得减法的结果.

由于补码的加法特性, 因此实际上, 加减计算中的取模操作本质上就是扔掉最高位, 将数值重新拉回有效范围的手段.

<font color=red><b>溢出判断</b></font>

在加减法计算过程中, 由于减法计算造成的进位, 并用取模丢弃最高位是预期的设计. 
但是除此之外, 还存在相加或相减时造成进位的情况, 此时若丢弃最高位, 结果是非预期设计的错误值, 因此需要进行溢出判断.

溢出判断有两种方式: 观察最高位进位法, 双符号位法

**观察最高位进位法**:

- 对于加法, 仅在正数+正数, 负数+负数这两种情况下才可能溢出, 不同符号的两数相加不会溢出.
- 对于减法, 仅在正数-负数, 负数-正数这两种情况下才可能溢出, 不同符号的两数相减不会溢出.

由于减法计算也是用过加法实现的, 因此只需要做如下判断:

> 若两个操作数符号相同, 结果与操作数的符号不同, 即为溢出.


**双符号位法**:

使用双符号位存储符号时, 真值需要通过模 4 计算, 丢弃最高的两位符号位.
双符号位用 `00` 代表正数, 用 `11` 代表负数.
在做加法计算时, 若计算结果的两个符号位不相等, 则发生溢出.
- 符号位 `01` 代表正溢出
- 符号位 `10` 代表负溢出

双符号位损失存储精度, 实际不常用.


## 乘法运算

### 真值乘法

首先分析手算乘法的过程, 两数相乘的结果符号通过正正得正等获得.

例如 $A=0.1101$ 和 $B=0.1011$ . 二者数值部分的计算过程如下:

$$
\begin{array}{r}
\texttt{0.1101}\\
\times\ \texttt{0.1011} \\
\hline
\texttt{1101} \\
\texttt{1101 } \\
\texttt{0000{ } } \\
\texttt{1101{ }{ } } \\
\hline
\texttt{0.10001111}
\end{array}\ 
\begin{array}{lc}
\\
\\
\cdots\cdots A\times 2^0 & A 不移位 \\
\cdots\cdots A\times 2^1 & A 左移1位 \\
\cdots\cdots 0\times 2^2 & 0 左移2位 \\
\cdots\cdots A\times 2^3 & A 左移3位 \\
\\
\end{array}
$$

因此 $A\times B = +0.10001111$ .

上述过程中包含多次左移, 以及对 4 次位积的相加运算.

改进的手算过程如下:

$$
\begin{align}
A\times B &= A\times0.{\color{red}1}{\color{orange}0}{\color{green}1}{\color{blue}1} \\
&=0.{\color{red}1}A+0.0{\color{orange}0}A+0.00{\color{green}1}A+0.000{\color{blue}1}A \\
&=0.{\color{red}1}A+0.0{\color{orange}0}A+0.00{\color{green}1}(A+0.{\color{blue}1}A) \\
&=0.{\color{red}1}A + 0.0{\color{orange}1}[{\color{orange}0}A + 0.{\color{green}1}(A+0.{\color{blue}1}A)] \\
&=0.{\color{red}1}\{A + 0.{\color{orange}1}[{\color{orange}0}A + 0.{\color{green}1}(A+0.{\color{blue}1}A)]\} \\
&={\color{red}2^{-1}}\{A+{\color{orange}2^{-1}}[0A+{\color{green}2^{-1}}(A+{\color{blue}2^{-1}}A)]\} \\
&={\color{red}2^{-1}}\{A+{\color{orange}2^{-1}}[0A+{\color{green}2^{-1}}(A+{\color{blue}2^{-1}}(A+0))]\}
\end{align}
$$

上述过程可以视作移位和加法两种运算.

假设最初状态的<font color=red><b>部分积</b></font>为 `0` , 分步计算的过程如下:

$$
\begin{array}{c|lr}
1 & {\color{blue}1}\times 被乘数+部分积\ (0) & A+0=0.1101+0.0000=0.1101 \\
2 & 右移1位,得到新部分积 & 2^{-1}(A+0) = 0.01101 \\
3 & {\color{green}1}\times被乘数+部分积 & A+2^{-1}(A+0) = 0.1101+0.01101=1.00111 \\
4 & 右移1位,得到新部分积 & 2^{-1}[A+2^{-1}(A+0)] = 0.100111 \\
5 & {\color{orange}0}\times被乘数 + 部分积 & 0\times A+2^{-1}[A+2^{-1}(A+0)] = 0.100111 \\
6 & 右移1位,得到新部分积 & 2^{-1}\{A+2^{-1}[A+2^{-1}(A+0)]\} = 0.0100111 \\
7 & {\color{red}1}\times被乘数 + 部分积 & A+2^{-1}\{A+2^{-1}[A+2^{-1}(A+0)]\} = 1.0001111 \\
8 & 右移1位,得到新部分积 & 2^{-1}\{A+2^{-1}\{A+2^{-1}[A+2^{-1}(A+0)]\}\} = 0.10001111
\end{array}
$$

实际使用一个寄存器存放被乘数, 一个寄存器存放乘积的高维, 另一个寄存器存放乘数以及乘积的低位.


### 原码乘法

原码乘法与真值乘法仅差符号位, 符号位通过异或求得, 再加上数值即可.

> 例如: 已知 $x=-0.1110$ , $y=-0.1101$ , 求 $[x\cdot y]_原$

符号位 $1\oplus 1 =0$ .

数值部分计算过程为:
1. `0.1110 × 1 = 0.1110` 
2. `0.1110` 右移 $1$ 位得到 `0.01110` , `0.01110 + (0.1110 × 0) = 0.01110`
3. `0.01110` 右移 $1$ 位得到 `0.001110` , `0.001110 + (0.1110 × 1) = 1.000110`
4. `1.000110` 右移 $1$ 位得到 `0.1000110` , `0.1000110 + (0.1110 × 1) = 1.0110110`
5. `1.0110110` 右移 $1$ 位得到 `0.10110110` .

本质上移位的过程和笔算过程是相同的, 不过是换成一种计算机更容易理解的表述.

为了提升运算速度, 可以使用<font color=red><b>原码两位乘</b></font>进行计算.
原码两位乘使用两位乘数计算新的部分积, 两位乘数的各个情况分别对应如下操作:

$$
\begin{array}{|c|c|}
\hline
乘数y_{n-1}y_n & 新的部分积 \\
\hline
00 & 新部分积=(原部分积 + 0 \times被乘数) >> 2 \\
\hline
01 & 新部分积=(原部分积 + 1 \times被乘数) >> 2 \\
\hline
10 & 新部分积=(原部分积 + 2 \times被乘数) >> 2 \\
\hline
11 & 新部分积=(原部分积 + 3 \times被乘数) >> 2 \\
\hline
\end{array}
$$

可以通过十进制乘法进行理解, 例如 $1123\times1111=1247653$ :

$$
\begin{array}{r}
\texttt{1123} \\
\texttt{× 1111} \\
\hline
\texttt{12353} \\
\texttt{12353{ }{ }} \\
\hline
\texttt{1247653}
\end{array}
$$

相当于一次性计算了被乘数 (1123) 与乘数 (1111) 两位的计算结果. 由于一次性计算了两位, 因此移位也需要一次移 2 位.

对于原码两位乘, $2\times被乘数$ 可以通过左移 $1$ 位实现, 但 $3\times被乘数$ 比较难以实现.
通常将 $3\times被乘数$ 视为 $(4-1)\times被乘数$ , 通过先减 $1\times被乘数$ 再加 $4\times被乘数$ .

上述过程涉及到**部分积的存储架构**. 部分积通常由两个主要的寄存器存储: 
- 累加器 (Accumulator, ACC) 存储高位部分积, 存储当前迭代的最高位结果, 以及所有累加操作的结果.
- 乘商寄存器 (Multiplier-Quotient Register, MQ) 存储低位部分积, 初始存储乘数, 在迭代过程逐渐存储结果的低位部分.

以上两个寄存器连接, 形成一个双倍字长的寄存器, 用于存储最终乘积.

$$
最终乘积=[ACC]|[MQ]
$$

进行 $-1\times被乘数$ 是在高位寄存器, 即 ACC 中进行的, 这是因为 ACC 寄存器有 ALU 单元, 是加减, 累加的唯一发生位置, 而 MQ 不具备 ALU 功能.

以一个实际案例说明:

> 设 $x=\texttt{0.111111}$ , $y=\texttt{-0.111001}$ , 使用原码二位乘求 $[x\cdot y]_{原}$

解:

- $[-x]_补 = \texttt{1.000001}$ 
- $2x = \texttt{1.111110}$ (临时溢出, 中间结果, 不能独立解释, 需要移位) 
- $|y|=\texttt{0.111001}$

首先演示笔算的原码二位乘:

$$
\begin{array}{r}
\texttt{0.111111} \\
\texttt{× 0.{\color{blue}11}{\color{green}10}{\color{red}01}} \\
\hline
\color{red}\texttt{111111} \\
\color{green}\texttt{1111110{ }{ }} \\
\color{blue}\texttt{10111101{ }{ }{ }{ }} \\
\hline
\texttt{0.111000000111}
\end{array}
$$

再加上符号位, 得到结果 $\texttt{1.111000000111}$ .

下面演示计算机计算过程:

设原始部分积为 $\texttt{000.000000}$ , 原始乘数为 $\texttt{0.{\color{blue}11}{\color{green}10}{\color{red}01}}$

第一次计算:
观察乘数的低端两位, 值为 $\texttt{\color{red}01}$ , 因此:

$$
新部分积 = 原部分积 + 1\times被乘数
$$

得到新的部分积为:

$$
\texttt{000.000000+{\color{red}01}*000.111111=0.000000+{\color{red}000.111111}=000.111111}
$$

第二次计算:
首先应当将原部分积右移 $2$ 位, 以便与新结果相加:

$$
\texttt{000.111111>>2=000.001111|11(MQ)}
$$

为了优化存储空间, 在上一步计算中, 低端两位的 $\texttt{\color{red}01}$ 已经使用, 因此可以右移移除, 而将原部分积因为右移多出原本寄存器长度的两位 $\texttt{11}$ 存入乘数寄存器中.  
乘商寄存器中仅保留 $\texttt{000.001111}$ .

观察乘数的中部两位, 值为 $\texttt{\color{green}10}$ , 因此:

$$
新部分积 = 原部分积 + 2\times被乘数
$$

得到新的部分积为:

$$
\texttt{000.001111+{\color{green}10}*000.111111=000.001111+{\color{green}001.111110}=010.001101|11(MQ)}
$$

第三次计算:
将原部分积右移 $2$ 位, 以便与新结果相加:

$$
\texttt{010.001101|11(MQ)>>2=000.100011|0111(MQ)}
$$

观察乘数的高端两位, 值为 $\texttt{\color{blue}11}$ , 因此:

$$
新部分积 = 原部分积 + (-1)\times被乘数 + 4\times被乘数
$$

首先计算 $原部分积 + (-1)\times被乘数$ :

$$
\texttt{000.100011+111.000001=111.100100|0111(MQ)}
$$

之后有两种选择:
- 先 $+4\times被乘数$ , 再右移 $2$ 位
- 先右移 $2$ 位, 再 $+4\times被乘数$

为了与其他情况统一, 都按照先加某倍被乘数, 再右移, 因此此处也先进行右移.

将上步计算得到的新部分积进行右移 $2$ 位:

$$
\texttt{111.100100|0111(MQ)>>2=111.111001|000111(MQ)}
$$

再进行 $中间部分积 + 4\times被乘数$ :

$$
\texttt{111.111001+000.111111=000.111000|000111(MQ)}
$$

注意, 此处直接加 $\texttt{000.111111}$ , 而没有加 $\texttt{4*000.111111}$ 这是因为之前已经先进行了移位操作, 此时不能再进行乘 4 操作.

最终得到的结果为 $\texttt{000.111000000111}$ 加上符号位后, 结果为 $\texttt{1.111000000111}$ .

过程中有以下几个重点内容:

**被乘数的小数点前有 $3$ 位, 而不是常见 $1$ 位符号位**:  
这是因为在乘法运算过程中, 需要有过渡的中间临时溢出结果, 而后续需要进行右移才能获得正确的内容, 为了确保右移的正确性, 需要在前面补充对应的位数.
例如对于二位乘, 每次计算结果都需要右移 $2$ 位, 在右移 $2$ 位后, 还要获得正确的符号为, 因此需要在小数点前补充 $3$ 位.

**$+3\times被乘数$ 的处理方式:**
之所以使用 $+3\times被乘数$ 的处理方式, 是因为这样可以规范化整个运算过程, 而不用额外的在一次计算中涉及另外的一次乘法计算, 这对其他优化算法有重要的意义, 比如 Booth 计算. 对于后续的效率提升有极大作用.

<font color=red><b>额外标记位</b></font>
可以观察到, 对于乘数中的 $\texttt{11}$ 部分, 人类可以正确的识别, 并知道应该拆成两步进行计算, 但是计算机需要更明确, 更直白的算法才能理解需要进行哪些动作.
基于此, 会拆出额外的1位标记位 $C_j$ , 用这个标记位来判断是否触发了 $\texttt{11}$ 的乘数部分, 并进行对应操作. 对应的运算规则为:

$$
\begin{array}{|c|c|}
\hline
乘数两位 & 标记位 C_j & 对应操作 \\
\hline
00 & 0 & 部分和+0\times被乘数后右移两位, 乘数右移两位, C_j不变 \\
\hline
01 & 0 & 部分和+1\times被乘数后右移两位, 乘数右移两位, C_j不变 \\
\hline
10 & 0 & 部分和+2\times被乘数后右移两位, 乘数右移两位, C_j不变 \\
\hline
11 & 0 & 部分和-1\times被乘数后右移两位, 乘数右移两位, C_j置\ 1 \\
\hline
00 & 1 & 部分和+1\times被乘数后右移两位, 乘数右移两位, C_j置\ 0 \\
\hline
01 & 1 & 部分和+2\times被乘数后右移两位, 乘数右移两位, C_j置\ 0 \\
\hline
10 & 1 & 部分和-1\times被乘数后右移两位, 乘数右移两位, C_j置\ 1 \\
\hline
11 & 1 & 部分和+0\times被乘数后右移两位, 乘数右移两位, C_j置\ 1 \\
\hline
\end{array}
$$

通过乘数的两位与标记位组成的 3-bit 命令, 可以确定某次的运算需要如何进行.

为了能够正确的组成 3-bit 命令, 需要在乘数的最前面添加一对 $\texttt{00}$ 这样可以保证能够和 $C_j$ 组成最后一次的命令.

将上文题目重新按 3-bit 命令重新梳理, 将右移放到每次操作的后面:

$$
\begin{array}{|c|c|}
\hline
部分积 & 乘数 & C_j & 命令码 & 说明 \\
\hline
\begin{array}{r}\texttt{ 000.000000}\end{array} & \texttt{|001110{\color{red}01}} & \texttt{0} & \texttt{010} & 初始状态 \\
\hline
\begin{array}{r}
\texttt{000.000000} \\
\texttt{+000.111111} \\
\texttt{=000.111111} \\
\texttt{>>2} \\
\texttt{000.001111}
\end{array} &
\texttt{11|0011{\color{red}10}} & \texttt{0} & \texttt{100} & 
\begin{array}{}根据\texttt{010}计算\end{array} \\
\hline
\begin{array}{r}
\texttt{000.001111} \\
\texttt{+001.111110} \\
\texttt{=010.001101} \\
\texttt{>>2} \\
\texttt{000.100011}
\end{array} &
\texttt{0111|00{\color{red}11}} & \texttt{0} & \texttt{110} & 
\begin{array}{}根据\texttt{100}计算\end{array}\\
\hline
\begin{array}{r}
\texttt{000.100011} \\
\texttt{+111.000001} \\
\texttt{=111.100100} \\
\texttt{>>2} \\
\texttt{111.111001}
\end{array} &
\texttt{000111|{\color{red}00}} & \texttt{1} & \texttt{001} & 
\begin{array}{}根据\texttt{110}计算 \\ C_j置\ 1\end{array} \\
\hline
\begin{array}{r}
\texttt{111.111001} \\
\texttt{+000.111111} \\
\texttt{=000.111000} \\
\end{array} &
\texttt{000111|00} & \texttt{0} & \texttt{000} & 
\begin{array}{}根据\texttt{001}计算 \\ 计算完成 \end{array} \\
\hline
\end{array}
$$


为了简化设计, 在定点系统中的乘法运算通常就是**纯整数乘法**, 或**纯小数乘法**, 这样可以避免溢出. 
这是因为两个纯小数相乘结果还是纯小数, 不会有整数位的部分, 也就不会产生溢出.


### 补码乘法

为了提升效率, 一些机器直接使用补码做乘法.

<font color=red><b>校正法</b></font>

计算 $[x]_补\cdot [y]_补$ 时, 是将 $[y]_补$ 按位进行拆分, 然后移位后求和进行计算. 

对于 $[y]_补$ 为正时:

$$
[x\cdot y]_补 = [x]_补\cdot y = [x]_补\cdot [y]_原
$$

可以按照原码乘法的规则计算.

对于 $[y]_补$ 为负时:

$$
[x\cdot y]_补 = [x]_补\cdot [-y]_原 + [-x]_补
$$

即按照正的 $[y]_补$ 计算结果后加上 $[-x]_补$ 进行校正.

推导过程为:

被乘数 $x$ 符号任意, 乘数 $y$ 符号为负.
- $[x]_补 = x_0.x_1x_2\cdots x_n$
- $[y]_补 = 1.y_1y_2\cdots y_n$

对于真值 $y$ 有 $[y]_补 = (y+2)(\text{mod 2})$ 

由于 $y<0$ , 因此有:

$$
\begin{align}
y &= [y]_补-2 \\
&= 1.y_1y_2\cdots y_n - 2 \\
&= 0.y_1y_2\cdots y_n - 1
\end{align}
$$

则:

$$
\begin{align}
x\cdot y &= x(0.y_1y_2\cdots y_n - 1) \\
&=x\cdot (0.y_1y_2\cdots y_n) - x
\end{align}
$$

因此有:

$$
[x\cdot y]_补 = [x\cdot (0.y_1y_2\cdots y_n)]_补 + [-x]_补
$$

例:

> 设 $[x]_补=\texttt{1.0101}$ , $[y]_补=\texttt{0.1101}$ , 使用补码一位乘求 $[x\cdot y]_{补}$

解:

乘数 $[y]_补$ 为正, 为了方便与原码计算进行对照, 写出被乘数与乘数的原码:
- $[x]_原 = \texttt{1.1011}$
- $[y]_原 = \texttt{0.1101}$

$$
\begin{array}{|c|c|}
\hline
原码计算 & 补码计算 & 说明 \\
\hline
\texttt{0.1011×0.1101} & \texttt{1.0101×0.1101}\\
\hline
\begin{array}{r}
\texttt{0.1011} \\
\texttt{×0.1101} \\
\hline
\texttt{1011} \\
\texttt{1011{ }{ }} \\
\hline
\texttt{110111} \\
\texttt{1011{ }{ }{ }} \\
\hline
\texttt{0.10001111}
\end{array} & 
\begin{array}{r}
\texttt{1.0101} \\
\texttt{×0.1101} \\
\hline
\texttt{1110101} \\
\texttt{10101{ }{ }} \\
\hline
\texttt{11001001} \\
\texttt{10101{ }{ }{ }} \\
\hline
\texttt{1.01110001}
\end{array} &
\begin{array}{c}
\texttt{ } \\
\texttt{ } \\
\texttt{ } \\
\texttt{} \\
此处二者相等\\
\texttt{ } \\
结果相等
\end{array}\\
\hline
\end{array}
$$

可以观察到, 使用补码进行计算时, 前面补位应该用 $\texttt{1}$ 而不是 $\texttt{0}$ .

此时不同位对应的补码值也可以直接进行相加, 可以得到正确的结果. 
因为乘数的每位都是数值位, 将其分开思考, 被乘数分别乘以 
- $\texttt{0.0001}$ 
- $\texttt{0.01}$ 
- $\texttt{0.1}$ 
这些乘法本质上仅是移位操作, 因此是正确的.
而将上述的乘积相加起来, 又是符合补码加法的, 因此也是正确的.
因此补码乘法在上述案例中可以直接按照原码乘法的计算方法进行.


例:

> 设 $[x]_补=\texttt{0.1101}$ , $[y]_补=\texttt{1.0101}$ , 使用补码一位乘求 $[x\cdot y]_{补}$

解:

乘数 $[y]_补$ 为负, 为了方便与原码计算进行对照, 写出被乘数与乘数的原码:
- $[x]_原 = \texttt{0.1101}$
- $[y]_原 = \texttt{1.1011}$

- $[-x]_补 = \texttt{1.0011}$

$$
\begin{array}{|c|c|}
\hline
原码计算 & 补码计算 \\
\hline
\texttt{0.1101×1.1011} & \texttt{0.1101×1.0101}\\
\hline
\begin{array}{r}
\texttt{0.1101} \\
\texttt{×0.1011} \\
\hline
\texttt{1101} \\
\texttt{1101{ }} \\
\hline
\texttt{100111} \\
\texttt{1101{ }{ }{ }} \\
\hline
\texttt{0.10001111}\\
\hline
\texttt{1.01110001}
\end{array} & 
\begin{array}{r}
\texttt{0.1101} \\
\texttt{×0.0101} \\
\hline
\texttt{1101} \\
\texttt{1101{ }{ }} \\
\hline
\texttt{0.01000001} \\
\texttt{+1.0011{ }{ }{ }{ }} \\
\hline
\texttt{1.01110001} \\
\texttt{}
\end{array}\\
\hline
\end{array}
$$

上述方法中, 结果的符号位是在运算过程中产生的, 而不是像原码计算一样是后续添加的.

校正法与乘数的符号有关, 实现较为麻烦, 若不考虑操作数符号, 可以使用比较法.

<font color=red><b>比较法 (Booth算法)</b></font>

推导过程如下:

设:
- $[x]_补 = x_0.x_1x_2\cdots x_n$
- $[y]_补=y_0.y_1y_2\cdots y_n$

按照校正法的规则, 补码乘法公式为:

$$
[x\cdot y]_补 = [x]_补(0.y_1y_2\cdots y_n) - [x]_补\cdot y_0
$$

当 $y_0=0$ 时, 乘数 $y$ 为正, 无需校正:

$$
[x\cdot y]_补 = [x]_补(0.y_1y_2\cdots y_n)
$$

当 $y_0=1$ 时, 乘数 $y$ 为负, 需要校正:

$$
[x\cdot y]_补 = [x]_补(0.y_1y_2\cdots y_n) - [x]_补
$$

在 $\text{mod 2}$ 前提下, $[-x]_补=-[x]_补$ .

$$
\begin{align}
[x\cdot y]_补
&=[x]_补(y_{1}2^{-1}+y_{2}2^{-2}+\cdots+y_{n}2^{-n}) - [x]_补\cdot y_0 \\
&=[x]_补(-y_0+y_{1}2^{-1}+y_{2}2^{-2}+\cdots+y_{n}2^{-n}) \\
&=[x]_补[-y_0+(y_{1}-y_{1}2^{-1})+(y_{2}-y_{2}2^{-2})+\cdots+(y_{n}-y_{n}2^{-n})] \\
&=[x]_补[(y_{1}-y_{0})+(y_{2}-y_{1})2^{-1}+\cdots+(y_{n}-y_{n-1})2^{-(n-1)}+(0-y_{n})2^{-n}] \\
&=[x]_补[(y_{1}-y_{0})+(y_{2}-y_{1})2^{-1}+\cdots+(y_{n+1}-y_{n})2^{-n}]
\end{align}
$$

其中, $y_{n+1}=0$ .

由此可以得到递推公式:

$$
\begin{array}{l}
[z_0]_补 = 0 \\
[z_1]_补 = 2^{-1}\{[z_0]_补 + (y_{n+1}-y_{n})[x]_补\} \\
[z_2]_补 = 2^{-1}\{[z_1]_补 + (y_{n}-y_{n-1})[x]_补\} \\
\ \ \ \qquad\vdots \\
[z_i]_补 = 2^{-1}\{[z_{i-1}]_补 + (y_{n-i+2}-y_{n-i+1})[x]_补\} \\
\ \ \ \qquad\vdots \\
[z_n]_补 = 2^{-1}\{[z_{n-1}]_补 + (y_{2}-y_{1})[x]_补\} \\
[x\cdot y]_补 = [z_{n+1}]_补 = [z_n]_补+(y_1-y_0)[x]_补
\end{array}
$$

