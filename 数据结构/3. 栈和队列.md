
# 栈

**栈**是是限定仅在表尾进行插入或删除的线性表.
表尾称为**栈顶**, 表头称为**栈底**.

栈是后进先出 (LIFO) 结构.

和普通线性表相似, 栈也有顺序存储和链式存储两种表示方法. 

栈应用的典型案例:

**进制转换**
其原理为不断计算求余结果, 将单数位结果压入栈, 最终结果从栈中依次取出.

**括号匹配检验**
依次读入括号, 若为右括号, 则或者与栈顶括号抵消, 或者不合法. 若为左括号, 压入栈中. 在算法开始和结束时, 栈应该是空的.

**行编辑程序**
在编辑器设计中, 可以添加一个缓冲区, 若用户发现单个字符输入错误, 可以删除单个字符, 若整行错误则整行删除. 接受一个用户输入的字符, 若为普通字符则压入栈顶, 若为删除单个字符, 则从栈顶删去一个元素, 若为整行删除, 则将栈清空.

**迷宫求解**
计算机求解迷宫问题通常考穷举, 即沿某方向前进, 若能走通则继续, 否则原路退回更换方向, 直到所有可能通路完成. 需要使用栈来保存从入口到当前位置的路径. 路径必须是简单路径, 即路径不能包含重复位置. 


**表达式求值**
表达式是由操作数, 运算符和界限符组成的.
操作数可以是常数, 也可以是被说明为变量或者常量的标识符.
运算符可以分为算术运算符, 关系运算符和逻辑运算符.
基本界限符有左右括号和表达式结束符等.

将运算符和界限符统称为运算符, 任意两个相继出现的算符 $\theta_1$ 和 $\theta_2$ 之间的有限关系至多是下面三种情况之一:
-  $\theta_1<\theta_2$     $\theta_1$ 的优先级低于 $\theta_2$ 
-  $\theta_1=\theta_2$     $\theta_1$ 的优先级等于 $\theta_2$ 
-  $\theta_1>\theta_2$     $\theta_1$ 的优先级高于 $\theta_2$ 
定义所有算符之间的优先关系. 当 " $($ " 和 " $)$ " 相遇时, 括号内运算完成.
由运算规则, $+ - \times \div$ 的优先级均低于 $($ , 高于 $)$ . 仅有 $()$ 和 $\#\#$ 标记为优先级相等.
不允许 $\theta_1 = )$ , $\theta_2 = ($ 的情况出现, 若出现则判定为语法错误.

使用两个栈来处理该问题, 一个寄存运算符 `OPTR` , 另一个寄存操作数或运算结果 `OPND` .
算法基本思想为:
1. 首先置操作数栈为空战, 表达式起始符 " $\#$ " 为运算符栈的栈底元素.
2. 依次读入表达式中的每个字符, 若为操作数, 则进 `OPND` ; 若为运算符, 则和栈顶运算符比较先后权, 然后进行相应操作. 直至整个表达式求值完成, 即 `OPTR` 栈的栈顶元素和当前读入的字符均为 " $\#$ ".
当前字符为操作符:
- 若栈顶操作符比当前字符操作符优先级低, 则将当前操作符压入 `OPTR` .
- 若栈顶操作符和当前字符操作符优先级相同, 则为括号, 直接pop栈顶脱括号.
- 若栈顶操作符比当前字符操作符优先级高, 则pop栈顶操作符与 `OPND` 的两个操作数, 进行运算后压入 `OPND` .


# 栈与递归

一些递归定义的函数:
- 阶乘
- Fibonacci数列
- Ackermann函数


## n阶Hanoi塔

有3个分别命名为 X, Y, Z的塔座, 在塔座X上有 $n$ 个依次从小到大的圆盘. 将所有圆盘从X移动至Z上, 并按照完全相同的顺序堆叠, 移动过程中满足以下规则:
1. 每次只能移动一个圆盘.
2. 圆盘可以插在X, Y, Z任意一个塔座上.
3. 任何时刻都要保证较大的圆盘不能再较小的圆盘上.

解决Hanoi塔问题本质是递归操作.
- 当 $n=1$ 时, 只需将1号圆盘从X直接移动到Z.
- 当 $n>1$ 时, 将 $n$ 上面的 $n-1$ 个圆盘从X移动到Y, 然后再将 $n$ 移动到Z上, 然后对于剩下的 $n-1$ 个圆盘重复上述动作, 直到全部移动到Z上.
- 对于 $n-1$ 个圆盘的移动操作和 $n$ 个圆盘的逻辑相同, 只是问题规模小1.


# 队列

与栈相反, **队列**是先进先出 (FIFO) 的线性表. 仅允许在一端进行插入, 在另一段取出删除. 允许插入的一端叫做队尾 (rear), 允许删除的一端叫队头 (front).

**双端队列**是限定插入和删除操作在表的两端进行的线性表, 两端分别称为端点1和端点2.
实际可以根据使用需求灵活调整端点是否允许插入或删除.


## 链队列

用链表表示的队列称为**链队列**. 链队列必须分别指定队头和队尾的指针. 链队列为空的判定条件为头指针和尾指针均指向头结点.


## 循环队列

使用顺序存储的结构存储队列, 也需要设定两个指针, 分别指向队头和队尾.
当新元素插入队尾时, 尾指针会 $+1$ , 而当从队列删除头元素时, 头指针会 $+1$ . 由此可见, 随着队列的不断增减元素, 队列指针会越过初始设定的空间, 造成溢出. 因此设计一个循环结构, 称为循环队列. 可以想象成一个环形队列方便理解. 

随着元素插入, rear同步后移; 随着元素取出, front同步后移. 若抵达空间上限, 若队列不满则从 $0$ 位置, 重新填充.

实际设计的时候, 应当空出一个元素空间, 使 $front≠rear$ 来避免无法判断队列为空还是队列已满. 或者专门设计一个标志位以区分队列为空还是队列已满.

循环队列不能动态分配一维数组, 若要使用循环队列, 则需要设定一个最大的队列长度.

