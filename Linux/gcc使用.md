# `gcc`使用

在开发板上卸载`GCC`:
```bash
sudo apt remove --purge gcc
sudo apt autoremove
```

安装`GCC`:
```bash
sudo apt update
sudo apt install gcc
```

`GCC`常用选项:
- `-o`: 小写字母"o",  指定生成的可执行文件的名字,  不指定的话生成的可执行文件名为a.out.
- `-E`: 只进行预处理,  既不编译,  也不汇编.
- `-S`: 只编译,  不汇编.
- `-c`: 编译并汇编,  但不进行链接.
- `-g`: 生成的可执行文件带调试信息,  方便使用gdb进行调试.
- `-Ox`: 大写字母"O"加数字,  设置程序的优化等级,  如"-O0""-O1" "-O2" "-O3",   数字越大代码的优化等级越高,  编译出来的程序一般会越小,  但有可能会导致程序不正常运行.

预处理阶段: 可理解成将头文件汇总成`C`代码,  得到`*.i`文件.
编译阶段: 将`C`代码转换为汇编代码,  得到`*.s`文件.
汇编阶段: 将汇编代码转换为机器码,  得到`*.o`文件.
链接阶段: 将文件调用关系链接,  将多个`*.o`文件最终组合成可执行文件.

Linux下生成的`*.o`目标文件`*.so`动态库文件以及最终的可执行文件都是`elf`格式的,  可以使用`readelf`工具来查看它们的内容.

使用如下命令可以使用静态链接:
```bash
gcc hello.c -o hello_static --static
```

使用`ldd`命令可以查看动态文件的库依赖:
```bash
root@host:/# ldd hello
	linux-vdso.so.1 (0x0000ffff97319000)
	libc.so.6 => /lib/aarch64-linux-gnu/libc.so.6 (0x0000ffff97151000)
	/lib/ld-linux-aarch64.so.1 (0x0000ffff972e9000)
```

`.so`动态库为了提升版本管理,  使用数字后缀进行管理,  如:
- `*.so` **开发时使用的链接名** (link name)
- `*.so.1` **soname** (shared object name)
- `*.so.1.2.3` **实际的库文件版本** (real file)

实际链接关系为:
```bash
libfoo.so        -> libfoo.so.1
libfoo.so.1      -> libfoo.so.1.2.3
libfoo.so.1.2.3  = 实际的库文件
```

# 从编译到运行的过程

1. 预处理hello.c, 主要是处理程序里面的文件包含, 处理宏定义, 条件编译. 
2. 把c文件编译成为汇编文件(.s), 其中进行了词法分析, 语法分析, 语义分析, 生成中间代码, 对代码进行优化等工作. 
3. 把汇编文件(.s)编译成可重定位文件(.o). 
4. 把可重定位文件(.o)链接成为可执行文件, 其中链接可分为静态链接和动态链接
	- 静态链接:在编译阶段就会把所有用到的库打包到自己的可执行程序中, 其优点是具有较好的兼容性, 不依赖外部环境, 但是生成的程序比较大. 
	- 动态链接:在应用程序运行时, 链接器去加载外部的共享库, 并完成共享库和动态编译程序之间的链接. 不同的程序可以共用代码库, 节省内存空间. 
5. 控制台输入./hello命令后, Shell会创建一个新的进程来执行该程序. fork()函数就是用于创建一个新的进程的. 这里的进程可以先简单理解为程序的容器. 
6. exeve()函数可以理解为向上一步新建的进程, 填充一个可执行程序(hello). 
7. sys_execve()函数为linux系统调用, 被exeve()函数调用, 这里的系统调用可以理解为是操作系统系统开放给用户的最底层接口. 
8. do_exeve()函数是sys_execve()函数的核心. 
9. load_elf_binary()函数会去文件系统中读取hello程序到内存, 然后判断它是否是动态链接的可执行程序, 如果不是, 则进一步判断是否是静态链接的文件. 
10. ld-linux-xx.so是glibc库中的动态连接器. 如果hello程序是动态链接程序, 该动态链接器会去加载共享库, 并完成共享库和程序的链接工作,  然后准备真正开始执行hell程序. 
11. 相反, 如果hello程序是静态编译的程序, 则无需再加载链接共享库, 直接开始准备执行hello程序. 
    - 第10和11步分别执行之后.都会开始执行hello程序, _start是程序的真正入口, 而该符号在glibc中. 也就是说程序的真正入口在glibc. 
12. __libc_start_main()也是glibc中的函数, 用于在执行用户程序前进行一些初始化工作. 
13. 调用用户程序中的mian()函数, 开始执行printf打印函数. 
14. 程序执行完了之后, 调用glibc库中的_exit()函数, 来结束当前进程. 

多个源文件以及包含头文件情况下的编译:
```bash
gcc -o hello hello_main.c hello_func.c -I .
```

指定输入源文件: `hello_main.c`以及`hello_func.c`.
`-I`参数指定头文件目录为`.`.
