
# 6.1 无符号数和有符号数

对于无符号数而言, 机器字长的每一位都用于存放数值.
对于有符号数而言, 需要留出存放符号的位置.
因此, 机器字长相同时, 无符号数和有符号数对应的数值范围是不同的.
例如机器字长为 16-bit 时
- 无符号数的表示范围为 `0 ~ 65535`
- 有符号数的表示范围为 `-32768 ~ +32767`


## 有符号数

### 机器数与真值

可以用 $0$ 表示 $正$ , 用 $1$ 表示 $负$ . 这样将符号数字化, 并规定将其放置于有效数字前, 组合成有符号数. 例如原码中:

有符号小数:
- `+0.1011` 表示为 `01011`
- `-0.1011` 表示为 `11011`
有符号整数:
- `+1100` 表示为 `01100`
- `-1100` 表示为 `11100`

将符号数字化的数称为<font color=red><b>机器数</b></font>, 将带有 `+/-` 号的数称为<font color=red><b>真值</b></font>.
为了能够使符号位和数值部分一起参与运算, 需要设计对应的编码.


### 原码

原码是机器数中最简单的表示形式, 符号位 $0$ 表示正数, $1$ 表示负数, 数值位即真值的绝对值.
原码又称为带符号的绝对值表示.
为了书写方便, 以及区分整数和小数, 约定整数的符号位与数值位之间用逗号隔开, 小数的符号位与数值位之间用小数点隔开, 例如上面 4 个数的源码分别为:
- `0.1011`
- `1.1011`
- `0,1100`
- `1,1100`

原码的详细定义如下.

整数原码定义为:

$$
[x]_{原} = 
\left\{
\begin{array}{ll}
0,x & 2^n>x\geq0\\
2^n-x & 0\geq x >-2^n
\end{array}
\right.
$$

其中, $x$ 为真值, $n$ 为整数的位数.
当为负数时, $2^n$ 实际是在原有数字前面的 $1$ , 而 $-x$ 就是 $+|x|$ .
需要注意使用 " $,$ " 将符号位与数值位分隔.

小数原码定义为:

$$
[x]_{原} = 
\left\{
\begin{array}{ll}
x & 1>x\geq0 \\
1-x & 0\geq x > -1
\end{array}
\right.
$$

其中, $x$ 为真值.

原码简单直观, 易于和真值转换. 但使用源码进行加减运算时, 却复杂繁琐. 
例如在做符号不同加法时, 需要判断两数绝对值大小, 然后做绝对值减法, 原本是加法运算, 却需要减法器实现. 
而设计目标是只在计算机中设加法器, 只做加法运算.


### 补码

例如 24 小时制的时钟, 若需要将 `6:00` 调至 `3:00` , 可以选择顺时针 `+9` 时, 或逆时针 `-3` 时. 结果一致, 分别对应:
- `06 + 09 = 15`
- `06 - 03 = 03`

再加上 $(\text{mod 12})$ 运算, 则 `+9` 和 `-3` 对于时钟作用相同.

称 $+9$ 是 $-3$ 以 $12$ 为模的补数, 记作:

$$
-3 \equiv +9 \quad (\text{mod 12})
$$

同理有:

$$
\begin{array}{}
-4 \equiv +8 \quad (\text{mod 12}) \\
-5 \equiv +7 \quad (\text{mod 12})
\end{array}
$$

因此, 确定 "模" 之后, 可以找到与负数等价的正数 (正数为该负数的补数) 来代替负数, 使减法可以由加法运算实现.

得出如下结论:
- 负数可用其正补数代替, 正补数可以用模加上负数本身计算
- 正数和负数互为补数时, 二者的和为模数
- 正数的补数是其本身

补码的详细定义如下.

整数的补码定义为:

$$
[x]_{原} = 
\left\{
\begin{array}{ll}
0,x & 2^n>x\geq0\\
2^{n+1}+x & 0\geq x >-2^n \quad (\text{mod }2^{n+1})
\end{array}
\right.
$$

其中, $x$ 为真值, $n$ 为整数的位数.
例如:
- `+1010` 的补码为 `0,1010`
- `-1101` 的补码为 `1,0011`

小数的补码定义为:

$$
[x]_{原} = 
\left\{
\begin{array}{ll}
x & 1>x\geq0 \\
2+x & 0 > x \geq -1 \quad (\text{mod }2)
\end{array}
\right.
$$

其中, $x$ 为真值.
例如:
- `+0.1001` 的补码为 `0.1001`
- `-0.0110` 的补码为 `10.0000 - 0.0110 = 1.1010`

补码的 `0` 唯一表示为 `0.0000` , 补码比源码多一种 `-1` 的表示: `1.0000` .

根据补码定义, 也可以用补码求真值:
- `1.0101` 的真值为 `1.0101 - 10.0000 = -0.1011`
- `1,1110` 的真值为 `1,1110 - 100000 = -0010`
- `0.1101` 的真值为 `0.1101`

补码的引入是为了消除减法运算, 但根据补码定义, 在形成补码的过程中仍然有减法.

但是本质上, 计算补码的过程就是一个凑模的过程, 例如求 `-1011` 的补码.

$$
[x]_补 = 2 ^ {4+1} + x = 100000 - 1011 = 1,0101
$$

观察 `1011` 和 `0101` 实际是对 `1011` 每位取反后 `+1` .

同理, 由补码求反码也可以通过取反加 1 实现.


### 反码

反码通常用来作为原码求补码, 或补码求原码的中间过渡. 反码的定义如下.

整数的反码定义为:

$$
[x]_{原} = 
\left\{
\begin{array}{ll}
0,x & 2^n>x\geq0\\
(2^{n+1}-1)+x & 0\geq x >-2^n \quad (\text{mod }(2^{n+1}-1))
\end{array}
\right.
$$

其中, $x$ 为真值, $n$ 为整数的位数.
例如:
- `+1101` 的反码为 `0,1101`
- `-1101` 的反码为 `1,0010`

小数的反码定义为:

$$
[x]_{原} = 
\left\{
\begin{array}{ll}
x & 1>x\geq0 \\
(2-2^{-n})+x & 0 > x \geq -1 \quad (\text{mod }(2-2^{-n}))
\end{array}
\right.
$$

其中, $x$ 为真值.
例如:
- `+0.0110` 的补码为 `0.0110`
- `-0.0110` 的补码为 `1.1111 - 0.0110 = 1.1001`

反码的 `0` 有两种表示: `0.0000` 和 `1.1111`

综上所述, 三种机器码的特点为:
- 最高位均为符号位, 符号位和数值位之间用 `.` 或 `,` 隔开.
- 当真值为正时, 原码, 补码, 反码相同.
- 当真值为负时, 补码是原码的<font color=red><b>求反加</b></font> $\color{red}1$ , 反码是原码的<font color=red><b>每位求反</b></font>.

使用 8 位空间, 可以存储的各类机器码的值表对应如下:

$$
\begin{array}{|c|c|}
\hline
二进制码 & 
\begin{array}{}{\color{red}无符号数}\\对应真值\end{array} & 
\begin{array}{}{\color{red}原码}\\对应真值\end{array} & 
\begin{array}{}{\color{red}补码}\\对应真值\end{array} & 
\begin{array}{}{\color{red}反码}\\对应真值\end{array} \\
\hline
00000000 & 0 & +0 & \pm0 & +0 \\
\hline
00000001 & 1 & +1 & +1 & +1 \\
\hline
00000010 & 2 & +2 & +2 & +2 \\
\hline
\vdots & \vdots & \vdots & \vdots & \vdots \\
\hline
01111110 & 126 & +126 & +126 & +126 \\
\hline
01111111 & 127 & +127 & +127 & +127 \\
\hline
10000000 & 128 & -0 & -128 & -127 \\
\hline
10000001 & 129 & -1 & -127 & -126 \\
\hline
10000010 & 130 & -2 & -126 & -125 \\
\hline
\vdots & \vdots & \vdots & \vdots & \vdots \\
\hline
11111101 & 253 & -125 & -3 & -2 \\
\hline
11111110 & 254 & -126 & -2 & -1 \\
\hline
11111111 & 255 & -127 & -1 & -0 \\
\hline
\end{array}
$$

补码比原码和反码可以多表示一个负数.


### 移码

在数字和数字进行比较的过程中, 由于表示符号的符号位是 `0` 代表正数, `1` 代表负数. 
在比较两数大小的时候不够直观. 因此诞生了移码.

移码的定义为:

$$
[x]_移 = 2^n + x \quad (2^n>x\geq-2^n)
$$

移码就是在真值上加 $2^n$ .
例如:
- `+10100` 的移码为 `100000 + 10100 = 1,10100`
- `-10100` 的移码为 `100000 - 10100 = 0,01100`

移码就是将补码的符号位翻转而已.


# 6.2 数的定点表示和浮点表示

## 定点表示

小数点固定在某一位置的数为定点数.

定点数只能表示纯整数或纯小数, 格式分别为:
- <font color=red><b>纯整数</b></font>: `± 数值 .`
- <font color=red><b>纯小数</b></font>: `± . 数值`

早期计算机通常只能处理一种数格式的运算, 分为单独的整数定点机和小数定点机.
- 整数定点机: 倾向于通用计算和数据处理, 只能处理纯整数.
- 小数定点机: 倾向于金融, 科学等大量小数运算的领域, 只能处理纯小数.

由于定点机的小数点位置固定, 因此处理非纯小数或纯整数的时候, 需要乘以比例因子.


## 浮点表示

实际计算机中的数据不一定是纯小数或纯整数, 而且数值的范围相差很大, 有极大的数和极小的数需要同时处理.
浮点数, 即小数点位置可以浮动的数.
通常, 浮点数被表示为:

$$
N = S \times r^{j}
$$
- $S$ 为尾数, 可正可负.
- $j$ 为阶码, 可正可负.
- $r$ 为基数.

在计算机中, 基数可取 $2,4,8,16$ 等.

以