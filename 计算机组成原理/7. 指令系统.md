
# 7.1 机器指令

<font color=red><b>机器指令</b></font>是 CPU 能够识别和执行的命令, 是计算机硬件能理解的唯一语言, 形式为二进制码.
将全部机器指令的集合称为机器的<font color=red><b>指令系统</b></font>. 机器的指令系统反映了机器的功能.

计算机的设计研究确定机器的指令系统, 用硬件, 芯片, 设备来实现机器指令系统的功能.
计算机的使用是根据机器提供的指令系统, 使用汇编语言编址程序.

通过指令系统, 可以了解机器功能, 内部的寄存器-存储器结构, 以及计算机支持的数据类型.

## 指令的一般格式

指令是由<font color=red><b>操作码</b></font>和<font color=red><b>地址码</b></font>两部分组成的:

$$
\begin{array}{|c|c|}
\hline
操作码字段 & 地址码字段 \\
\hline
\end{array}
$$

### 操作码

**操作码**指明该指令需要完成的操作, 如: 加法, 减法, 传送, 移位, 转移等.

通常, 操作码的位数反映机器支持的操作数量, 例如操作码占 7 位, 则机器最多支持 $2^7=128$ 条指令.

操作码的长度可以是固定的, 也可以是变化的. 
- 定长操作码通常将操作码排列到指令的固定范围, 译码时间短, 便于硬件设计.
- 不定长操作码分布在指令字的不同字段, 可以压缩操作码的平均长度. 操作码变长会增加指令译码和分析难度, 使控制器设计复杂. 
  通常采用扩展操作码技术, 使操作码的长度随地址的减少而增加. 不同地址数的指令可以具有不同长度的操作码. 例如:
	- 4-bit 操作码对应 $0000\sim1110$ 共 15 条**三地址指令**.
	- 8-bit 操作码对应 $1111\ 0000 \sim 1111\ 1110$ 共 15 条**二地址指令**.
	- 12-bit 操作码对应 $1111\ 1111\ 0000\sim1111\ 1111\ 1110$ 共 15 条**一地址指令**.

另外, 还可以按不同的方案分配不同地址指令的数量, 例如可以缩减二地址指令的数量, 扩展一地址指令的数量.

例如 CISC 的 x86 和 amd64 指令集就是变长度指令, 操作码也是变长操作码.
而 RISC 的指令集就是固定长度指令, 其操作码也是定长操作码.

在设计不固定长度操作码指令系统时, 需要考虑指令使用频率, 将高频指令设计成指令占用短的操作码, 提升译码效率.


### 地址码

地址码用来指出该指令源操作数的地址 (一个或两个), 结果的地址以及下一条指令的地址.
地址可以是主存地址, 寄存器地址, I/O设备地址.

<font color=red><b>四地址指令</b></font>

$$
\begin{array}{|c|c|}
\hline
OP & A_1 & A_2 & A_3 & A_4 \\
\hline
\end{array}
$$

其中:
- $OP$ 是操作码 
- $A_1$ 是第一操作数地址 
- $A_2$ 是第二操作数地址 
- $A_3$ 是结果地址 
- $A_4$ 是下条指令地址

该指令完成 $(A_1)OP(A_2)\rightarrow A_3$ 操作.

若地址字段均为主存地址, 则需要访存 4 次 (取指令一次, 取操作数两次, 存结果一次).

由于程序中大多数指令是按顺序执行的, 程序计数器 $PC$ 既能存放当前预执行指令的地址, 又有计数功能, 因此能够自动生成下一条指令地址, 因此省略第四地址字段 $A_4$ , 形成三地址指令.

<font color=red><b>三地址指令</b></font>

$$
\begin{array}{|c|c|}
\hline
OP & A_1 & A_2 & A_3 \\
\hline
\end{array}
$$

完成 $(A_1)OP(A_2)\rightarrow A_3$ 操作, 后续指令地址隐含在程序计数器 $PC$ 中.

若地址字段均为主存地址, 则需要访存 4 次. 寻址范围相较四地址指令提升.

机器运行过程中, 没有必要每次运算结果都存入主存, 中间结果可以暂存在 CPU 寄存器 (如 ACC) 中, 因此可以省略 $A_3$ , 形成二地址指令.

<font color=red><b>二地址指令</b></font>

$$
\begin{array}{|c|c|}
\hline
OP & A_1 & A_2 \\
\hline
\end{array}
$$

完成 $(A_1)OP(A_2)\rightarrow A_1$ 操作, 部分机器也可以表示 $(A_1)OP(A_2)\rightarrow A_2$ 的操作. 

若地址字段均为主存地址, 则需要访存 4 次. 若使其操作为 $(A_1)OP(A_2)\rightarrow ACC$ , 则只需访存 3 次. 寻址范围相较三地址指令提升.

若将一个操作数地址隐含在 ACC 中, 则指令字中仅需要给出一个地址码, 形成一地址指令.

<font color=red><b>一地址指令</b></font>

$$
\begin{array}{|c|c|}
\hline
OP & A_1 \\
\hline
\end{array}
$$

完成 $(ACC)OP(A_1)\rightarrow ACC$ 操作. 

需要访存 2 次. 寻址范围相较二地址指令提升.

<font color=red><b>零地址指令</b></font>

$$
\begin{array}{|c|c|}
\hline
OP \\
\hline
\end{array}
$$

无地址码, 例如:
- 空操作 ($NOP$)
- 停机 ($HALT$)

再如:
- 子程序返回 ($RET$)
- 中断返回 ($IRET$)
指令没有地址码, 其操作数的地址隐含在堆栈指针 $SP$ 中.


## 指令字长

指令字长取决于操作码长度, 操作数地址长度, 操作数地址个数. 

早期计算机指令字长, 机器字长和存储字长相等, 因此存储单元存储完整的指令或数据. 机器指令字长固定, 控制方式简单.

随着计算机发展, 出现了变长指令, 如单字长指令, 多字长指令. 
多字长指令需要多次访存才能获得完整的指令, 造成 CPU 速度下降. 
为了提高指令的运行速度, 节省存储空间, 将常用的指令设计成单字长指令或短字长格式的指令.


# 7.2 操作数类型和操作类型

## 操作数类型

操作数类型包括地址, 数字, 字符, 逻辑数据等.

计算机的数据存放于存储器或寄存器中, 寄存器的位数反映机器字长. 一般机器字长取字节的 1, 2, 4, 8 倍, 便于字符处理.

数据存储分为边界对准和边界不对准, 不对准的存储方式, 数据可能分别存储在两个存储单元内, 读取时需要分多次读取.


## 操作类型

不同机器操作类型不同, 以下几类基本所有机器都包含:

### 数据传送

数据传送包括寄存器与寄存器, 寄存器与存储单元, 存储单元与存储单元之间的传送. 
例如:
- 从源到目的之间的传送
- 存储器读 ( $LOAD$ )
- 存储器写 ( $STORE$ )
- 交换源和目的的数据
- 置 $1$ 
- 清零
- 进栈
- 出栈
等.


### 算数逻辑操作

算数运算:
- 加, 减, 乘, 除, 增 $1$ , 减 $1$ , 取负数等.

逻辑运算:
- 与, 或, 非, 异或.

此外还有位操作, 如位测试, 位清除, 位求反等.


### 移位

移位分为:
- 算数移位
- 逻辑移位
- 循环移位

算数移位主要对有符号数进行处理, 目的是移位时保持数的符号不变, 效果相当于 $\times 2^n$ 或 $\div 2^n$ .

逻辑移位主要对无符号数进行处理, 将数字视为无符号位, 左移右移一律补 $0$ .


### 转移

多数情况下程序顺序执行, 使用转移指令改变执行顺序, 例如:
- **无条件转移**:
  如 $\text{JMP X}$ 将指令地址无条件跳转到 $X$ .

- **条件转移**:
  机器通常提供一些条件码, 这些条件码是某些操作的结果, 例如: 零标志位 ( $Z$ ) , 负标志位 ( $N$ ) , 溢出标志位 ( $V$ ) , 进位标志位 (  $C$ ) , 奇偶标志位 ( $P$ ).
  如 $\text{BRO X}$ 表示若结果溢出, 则跳转至 $X$ .
  如 $\text{BRC Y}$ 表示若最高位有进位, 则跳转至 $Y$ .
  如 $SKP$ 表示条件跳过下一条指令, 后面加跳过条件.

- **调用与返回**:
  有些特定功能的程序会反复使用, 为避免重复编写, 可作为独立子程序, 当执行子程序是需要使用子程序调用指令.
  计算机通常提供通用子程序, 如资源申请, 读写文件, 控制外设等.
  调用指令 ( $CALL$ ) 通常和返回指令 ( $RETURN$ ) 配合使用. $CALL$ 用于从当前程序位置转至子程序入口, $RETURN$ 用于子程序执行完后重新返回原程序断点.
  调用与返回有如下注意事项:
	- 子程序可以在多出被调用
	- 子程序调用允许嵌套
	- 每个 $CALL$ 都对应一个 $RETURN$
  由于调用后需要返回, 因此 CPU 必须记录返回地址, 可以存放于:
	- 寄存器. 专用寄存器用于存放返回地址.
	- 子程序的入口地址内.
	- 栈顶.

- **陷阱**:
  陷阱是一种意外事故中断, 例如: 电压失稳, 存储器校验出错, 输入输出设备故障, 未定义指令调用, 除数为 $0$ , 结果溢出等.
  出现以上问题需要及时采取措施, 避免系统正常运行. 一旦出现意外故障, 机器会发出陷阱信号, 暂停当前程序的执行, 转入故障处理程序.
  陷阱指令通常不提供给用户直接使用, 作为隐藏指令, 在意外出现时, 由 CPU 自动产生并执行. 也有部分机器提供陷阱指令给用户作为软中断使用.


### 输入输出

对于 I/O 单独编址的计算机, 通常有单独的输入输出指令, 完成 CPU 寄存器和外设寄存器的数据交换.


### 其他

包括等待指令, 停机指令, 空操作指令, 开中断指令, 关中断指令, 置条件码指令等.

为了提升信息处理能力, 一些计算机还有非数值处理指令, 如字符串传送, 比较, 查询, 转换等.

在多用户, 多任务计算机中, 还有特权指令, 用于操作系统.

对于设计向量计算的设备, 还有向量指令, 可对向量或矩阵进行运算.


# 7.3 寻址方式

寻址方式是指确定本条指令的数据地址, 以及下一条指令地址的方法.
寻址方式与硬件结构相关, 直接影响指令格式和指令功能.

寻址方式分为**指令寻址**和**数据寻址**两大类.

## 指令寻址

指令寻址较为简单, 分为<font color=red><b>顺序寻址</b></font>和<font color=red><b>跳跃寻址</b></font>两种.

顺序寻址可通过程序计数器 PC 加 $1$ , 自动形成下一条指令的地址.
跳跃寻址通过转移类指令实现.

若程序的首地址为 $0$ , 则先将 $0$ 送至程序计数器 PC 中, 启动机器后, 程序变按照 $0\rightarrow1\rightarrow2\rightarrow\cdots$ 执行, 若遇到转移类指令, 则跳跃到对应的指令.

跳跃寻址的转移地址行程方式参考数据寻址中的**直接寻址**和**相对寻址**.


## 数据寻址

数据寻址种类较多, 在指令字中必须设一字段用于指明寻址方式.
指令的地址码通常不代表操作数的真实地址, 因此称为<font color=red><b>形式地址</b></font>, 记作 $A$ . 

$$
\begin{array}{|c|c|}
\hline
操作码 & 寻址特征 & 形式地址A \\
\hline
\end{array}
$$

操作数的真实地址称为<font color=red><b>有效地址</b></font>, 记作 $EA$ .有效地址由寻址方式和形式地址共同确定.

### 立即寻址

立即寻址的特点是操作数本身即在指令字内, 即指令中的形式地址 $A$ 不是地址, 而是操作数本身, 又称之为**立即数**.

其特点为, 只要取出指令, 便可立即获得操作数, 不必访问存储器.
$A$ 的位数限制了立即寻址所能表述的立即数的范围.


### 直接寻址

直接寻址指令字中的形式地址 $A$ 就是操作数的真实地址 $EA$ , 即:

$$
EA = A
$$

其特点为, 寻找操作数比较简单, 不需要专门计算操作数地址, 在指令执行阶段, 对主存仅访问一次.
$A$ 限制了操作数的寻址范围, 而且必须修改 $A$ 的值才能修改操作数的地址.


### 隐含寻址

隐含寻址指令字中不明显地给出操作数地址, 而是意味着操作数地址隐含在操作码或某个寄存器中. 
例如一地址格式的加法指令只给出一个操作数地址, 另一个操作数隐含在累加器 ACC 中, ACC 即为隐含的操作数地址.

隐含寻址在指令字中少了一个地址, 使用隐含寻址的指令有利于缩短指令字长.


### 间接寻址

间接寻址指令字中的形式地址不直接指出操作数地址, 而是指出操作数有效地址的存储地址:

$$
EA = (A)
$$

间接寻址类似指针. 形式地址 $A$ 指向 $EA$ , $EA$ 地址内存储操作数的实际地址.

间接寻址可以嵌套.

间接寻址可以拓展操作数寻址范围, 因为 $A$ 的位数通常小于指令字长, 而完整存储字长可以存储寻址范围更大的地址.

间接寻址有利于编程, 参考指针.

间接寻址的缺点在于指令的执行阶段需要进行两次以上的寻址, 指令执行时间延长.


### 寄存器寻址

寄存器寻址指令字中, 地址码字段直接指出寄存器编号, 即 $EA=R_i$ . 其操作数在 $R_i$ 指向的寄存器内.
寄存器寻址在指令执行阶段不需要访存, 缩短执行时间, 指令字也较短.


### 寄存器间接寻址

相较于寄存器寻址, 寄存器间接寻址的 $R_i$ 指向的寄存器内存储的不是操作数, 而是操作数地址, 即 $EA = (R_i)$ .
寄存器间接寻址在指令执行阶段需要访存. 比间接寻址减少了一次访存 (有效地址位于寄存器).


### 基址寻址

基址寻址需要**基址寄存器** $BR$ , 其操作数的有效地址 $EA$ 等于指令字中的形式地址与基址寄存器中的值 (称为**基地址**) 相加:

$$
EA = A + (BR)
$$

基址寄存器可采用隐式和显式两种.
- **隐式基址寻址**, 是在计算机内有一个专门的基址寄存器 $BR$ , 用户不需要显式指出基址寄存器地址, 只需由指令的寻址特征位反映出寻址方式位基址寻址即可.
- **显示基址寻址**, 是在一组通用寄存器中, 用户明确指出由哪个寄存器作为基址寄存器, 存放基地址.

基址寻址可以扩大操作数寻址范围. 例如将主存空间分段, 每段首地址存储于基址寄存器, 与形式地址组合得到真实地址.

基址寻址的作用类似 MMU, 在多程序中作用明显, 赋予一个基地址后, 程序中的逻辑地址可以和基地址组合形成物理地址, 而用户不关心程序在主存中的实际位置.


### 变址寻址

变址寻址与基址寻址相似. 有效地址 $EA$ 等于指令字中的形式地址 $A$ 与变址寄存器 $IX$ 的内容组合:

$$
EA = A + (IX)
$$

基址寻址通常用于为程序或数据分配存储空间, **基址不变, 形式地址变**.
变址寻址的变址寄存器是用户设定的, **基址变, 形式地址不变**.

变址寻址通常用于输出处理, 将形式地址 $A$ 设定为数组首地址, $IX$ 类似 index, 组合形成数组中任意元素的地址.


### 相对寻址

相对寻址的有效地址是将程序计数器 PC 的内容 (即当前指令的地址) 与指令字中的形式地址 $A$ 相加形成, 即:

$$
EA = (PC) + A
$$

PC 中存放的是下一条指令的地址, 也称为指令指针.

因此相对寻址是提供一个相对当前指令地址的偏移量.


### 堆栈寻址

堆栈寻址要求计算机有栈结构 (Stack). 堆栈可以用寄存器组实现 (硬堆栈) 实现, 也可以用主存的部分空间实现 (软堆栈).
设定一个栈顶指针 SP (Stack Point), 栈顶指针指向栈顶, 操作数只能从栈顶的存储单元存取.
堆栈寻址可以看做一种隐含寻址, 操作数地址隐含在 SP 中.

SP 始终指向栈顶, 因此 PUSH 和 POP 都会改变 SP 的值.
