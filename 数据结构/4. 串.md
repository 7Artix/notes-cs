
**串** (string) 或字符串, 是由零个或多个字符组成的有限序列, 记为 

$$s='a_1 a_2 \cdots a_n' \quad (n \geq 0)$$

$s$ 是串名, 值中的每个字符都可以是字母, 数字或其他字符. 串中字符的数量称为串的长度, 零个字符的串称为空串.

串中任意个连续的字符组成的子序列称为子串. 对应子串的原序列称为主串. 字符在序列中的序号称为该字符在串中的位置. 子串在主串中的位置用子串的第一个字符在主串中的位置表示.

当且仅当两个串的长度相等, 且每个位置对应的字符都相同, 称两个串相等.

由一个或多个空格组成的串称为空格串.

串的最小操作子集包括:
- 串赋值
- 串比较
- 求串长
- 串联接
- 求子串


# 串的存储方式

**顺序存储**
类似于线性表的存储结构, 串也可以顺序存储.
若串的长度超出预定长度范围, 则会被舍去, 称之为截断.

**堆分配存储**
在C中存在一个称为"堆"的自由存储区, 由C的动态分配函数 `malloc()` 和 `free()` 管理. 
可以使用`malloc()` 为新产生的串分配一块实际串长所需的存储空间, 若分配成功, 则返回一个指向起始地址的指针, 作为串的基址, 同时也可以将串长也作为存储结构的一部分. 通过结构体实现.

**块链存储**
使用链式存储结构存储串, 每个节点可能有多个字符, 称为块链结构. 存储多个字符也是通过一个数组实现的, 因此是多个数组通过链表链接在一起. 
除了需要考虑数组的顺序存储方式, 还需要设计对应的节点大小, 节点大小影响串的处理效率.
$存储密度=\frac{串值所占存储位}{实际分配存储位}$ , 当存储密度小时, 运算处理方便, 但存储占用大. 
串的链式存储在链接操作等有便利性, 但总体灵活性不如顺序存储和堆分配存储.

子串的定位操作通常称为串的**模式匹配**. 简单匹配的时间复杂度为 $O(m*n)$ 
在匹配中, 目标模板的串为模式串 (T串) , 待查找的主串为S串.

## KMP算法
子串匹配的改进算法为**KMP算法**. 时间复杂度为 $O(m+n)$
改进点在于匹配失败时, 不回溯指向S串的指针, 而是利用已经得到的部分匹配的结果将模式向右滑动尽可能远后继续比较.
KMP需要维护一个部分匹配表, 即一个 $next$ 数组, 其定义为:

$$
next[j]=
\left\{
\begin{array}{rl}
0 & 当j=1 \\
\max\{k \ | \ 1<k<j \ 且 \ 'p_1\cdots p_{k-1}'='p_{j-k+1}\cdots p_{j-1}'\} & 当集合不为空 \\
1 & 其他情况
\end{array}
\right.
$$

[KMP Wikipedia](https://zh.wikipedia.org/wiki/KMP算法)


# 串的应用

**文本编辑**
可以将整个文本看做一个字符串, 称为文本串, 页是文本串的子串, 行是页的子串.
为了管理文本串的页和行, 通常会建立初始的页表和航标, 即建立子串的存储映像.
页表的每项确定也得页号和其实行号, 行表只是每一行的行号, 起始地址, 改行字符串长度.
文本编辑程序中设立页指针, 行指针, 字符指针.

**建立词索引表**
信息检索

