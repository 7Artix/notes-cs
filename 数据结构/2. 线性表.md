线性结构的特点为:
1. 存在唯一的一个被称为"第一个"的数据元素
2. 存在唯一的一个被称为"最后一个"的数据元素
3. 除第一个外, 集合的每个数据元素均只有一个前驱
4. 除最后一个外, 集合的每个数据元素均只有一个后继

线性表是 $n$ 个数据元素的有限序列. 


# 线性表的顺序表示

## 数组

线性表的**顺序表示**: 用一组地址连续的存储单元依次存储数据表的数据元素.
对于顺序表示的线性表, 只要确定了起始位置, 对于任意数据元素都可以随机存取, 所以线性表的顺序存储结构是一种**随机存取**的存储结构.

线性表的插入数据元素与删除数据元素:
- 在插入元素时, 需要创建新内存空间, 然后将插入index后的元素依次后移, 然后再插入新元素.
- 在删除元素时, 首先删除该元素, 然后将删除index后的元素依次前移.

插入元素和删除元素的主要耗时在移动元素上, 取决于插入或删除元素的位置.

设 $p_i$ 是在第 $i$ 个元素之前插入一个元素的概率, 则在长度为 $n$ 的线性表中插入一个元素时, 所需移动元素次数的期望 (平均移动次数) 为:

$$
E_{is} = \sum_{i=1}^{n+1}p_i(n-i+1)
$$

设 $q_i$ 是删除第 $i$ 个元素的概率, 则在长度为 $n$ 的线性表中删除一个元素时, 所需移动元素次数的期望 (平均移动次数) 为:

$$
E_{dl} = \sum_{i=1}^{n}q_i(n-i)
$$

假设线性表在任何位置插入或删除元素的概率是相等的, 即:

$$
p_i=\frac{1}{n+1}, \quad q_i=\frac{1}{n}
$$

则移动的期望值为:

$$
E_{is} = \frac{n}{2} , \quad E_{dl} = \frac{n-1}{2}
$$

其时间复杂度为 $O(n)$ .


# 线性表的链式表示

## 单链表

顺序表示的线性表能够随机存取, 但是也有弱点, 在于在插入或删除操作时, 需要移动大量元素.

链式表示的线性表不要求逻辑上相邻的元素在物理存储位置上也连续, 在插入或删除时不需要大量移动元素, 但是不能随机存取.

链式存储结构的特点是用一组任意的存储单元存储线性表的数据元素, 这些存储单元可以是连续的或非连续的. 
存储一个数据元素的存储映像称为**结点**, 包含两个域, 分别是数据域和指针域, 数据域存储本身的信息, 指针域存储后继的信息 (存储位置) . 

链表中每个结点只包含一个指针域, 因此称为**线性链表**或**单链表**.

一个链表结点形式如下:

```c
typedef struct LNode {
	ElementType data;
	struct LNode *next;
} LNode, * LinkList
```

在上述代码中, `struct LNode` 中的 `LNode` 是结构体标签, 而后面的 `LNode` 是别名, 另外 `* LinkList` 也是别名, 使用 `LinkList` 等同于使用 `struct LNode *` .

在这里需要结构体标签的原因是结构体内部定义存在递归, 若无递归则可以省略结构体标签.

创建链表的时候, 要使用 `LinkList` 这种指向头结点的指针的形式进行创建, 而不是通过一个结点来创建, 这样的目的是不丢失链表, 而且能够方便的操作链表的起始点, 能够通过头指针操作整个链表.

单链表是非随机存取结构, 获取第 $i$ 个元素必须从头指针出发寻找.

对于单链表的插入和删除指定的第 $i$ 个结点, 其时间复杂度为 $O(n)$ 因为首先需要找到第 $i$ 个结点. 

每个结点通常使用 `malloc` 和 `free` 管理.

单链表是**动态结构**, 每个链表占用的空间不需要预先分配划定, 可以根据需求即时生成. 


## 静态链表

```c
#define MAXSIZE 1000
typedef struct {
	ElementType data;
	int cur;
}component, SLinkList[MAXSIZE];
```

用一个结构体数组存储链表, 初始化时需要指定空间大小, 数组中有一个整型变量用来代替指针指示结点在数组中的相对位置.

在使用时有些约定:
`sLinkList[0]` 通常不存储实际数据, 而是用作一个头结点, 其 `cur` 成员指向链表中第一个实际数据结点在数组中的下标.

`sLinkList[MAXSIZE-1]` 可能用作备用链表头 (空闲链表).

静态链表中维护了一个空闲链表, 通常是一个整数变量, 来充当这个虚拟的链表的头游标. 其目的是为了分辨数组中哪些分量未被使用. 将所有未使用以及被删除的分量用游标链成一个空闲链表, 当插入时可以从空闲链表上取得第一个结点作为待插入的新结点, 在删除时将结点从链表中删除链接到空闲链表上.

在具体使用中:
1. 初始化: 首先将数组初始化一个空链表, 需要将所有元素的 `cur` 成员都按顺序的指向下一个元素的下标.
2. 分配结点 (`malloc` 模拟) : 创建新结点时, 不调用系统的 `malloc()` 函数, 而是从空闲链表头部中取出一个元素的下标, 建立链接关系, 然后更新空闲链表头.
3. 释放结点 (`free` 模拟): 释放结点时, 将该结点的 `cur` 成员指向空闲链表的头部, 然后更新空闲链表头指向该结点.
4. 插入结点: 首先分配新结点, 将新结点赋值, 然后调整前驱结点的 `cur` 到新节点, 而新结点的 `cur` 指向原本前驱结点的下一个结点.
5. 删除结点: 找到要删除结点的前驱节点, 修改前驱结点的 `cur` 到被删除结点的下一个结点. 将被删除的结点释放.


## 循环链表

将链表中最后一个结点的指针域指向头结点, 整个链表形成一个**环**.

空表的时候头结点的指针域指向自身.


## 双向链表

双线链表有两个指针域, 一个指向后继, 另外一个指向前驱.


## 多重链表

多重链表的结点可以同时属于多个不同的链表, 允许一个结点有多个指针域, 每个指针域链接到不同的逻辑链上. 实际少用.


# 一元多项式的表示及相加

符号多项式操作是表处理的典型用例.

可以使用顺序存储结构用来存储或处理一元多项式, 但存在问题, 如多项式的次数可能变化很大, 在处理最高次很大, 但仅有少数几项高次项, 而总项数很少的情况下, 使用顺序存储浪费空间, 可以同时存储系数与对应的指数.

可以使用顺序存储结构或链式存储结构.

