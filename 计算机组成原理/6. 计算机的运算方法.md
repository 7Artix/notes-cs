
# 6.1 无符号数和有符号数

对于无符号数而言, 机器字长的每一位都用于存放数值.
对于有符号数而言, 需要留出存放符号的位置.
因此, 机器字长相同时, 无符号数和有符号数对应的数值范围是不同的.
例如机器字长为 16-bit 时
- 无符号数的表示范围为 `0 ~ 65535`
- 有符号数的表示范围为 `-32768 ~ +32767`


## 有符号数

### 机器数与真值

可以用 $0$ 表示 $正$ , 用 $1$ 表示 $负$ . 这样将符号数字化, 并规定将其放置于有效数字前, 组合成有符号数. 例如原码中:

有符号小数:
- `+0.1011` 表示为 `01011`
- `-0.1011` 表示为 `11011`
有符号整数:
- `+1100` 表示为 `01100`
- `-1100` 表示为 `11100`

将符号数字化的数称为<font color=red><b>机器数</b></font>, 将带有 `+/-` 号的数称为<font color=red><b>真值</b></font>.
为了能够使符号位和数值部分一起参与运算, 需要设计对应的编码.


### 原码

原码是机器数中最简单的表示形式, 符号位 $0$ 表示正数, $1$ 表示负数, 数值位即真值的绝对值.
原码又称为带符号的绝对值表示.
为了书写方便, 以及区分整数和小数, 约定整数的符号位与数值位之间用逗号隔开, 小数的符号位与数值位之间用小数点隔开, 例如上面 4 个数的源码分别为:
- `0.1011`
- `1.1011`
- `0,1100`
- `1,1100`

原码的详细定义如下.

整数原码定义为:

$$
[x]_{原} = 
\left\{
\begin{array}{ll}
0,x & 2^n>x\geq0\\
2^n-x & 0\geq x >-2^n
\end{array}
\right.
$$

其中, $x$ 为真值, $n$ 为整数的位数.
当为负数时, $2^n$ 实际是在原有数字前面的 $1$ , 而 $-x$ 就是 $+|x|$ .
需要注意使用 " $,$ " 将符号位与数值位分隔.

小数原码定义为:

$$
[x]_{原} = 
\left\{
\begin{array}{ll}
x & 1>x\geq0 \\
1-x & 0\geq x > -1
\end{array}
\right.
$$

其中, $x$ 为真值.

原码简单直观, 易于和真值转换. 但使用源码进行加减运算时, 却复杂繁琐. 
例如在做符号不同加法时, 需要判断两数绝对值大小, 然后做绝对值减法, 原本是加法运算, 却需要减法器实现. 
而设计目标是只在计算机中设加法器, 只做加法运算.


### 补码

例如 24 小时制的时钟, 若需要将 `6:00` 调至 `3:00` , 可以选择顺时针 `+9` 时, 或逆时针 `-3` 时. 结果一致, 分别对应:
- `06 + 09 = 15`
- `06 - 03 = 03`

再加上 $(\text{mod 12})$ 运算, 则 `+9` 和 `-3` 对于时钟作用相同.

称 $+9$ 是 $-3$ 以 $12$ 为模的补数, 记作:

$$
-3 \equiv +9 \quad (\text{mod 12})
$$

同理有:

$$
\begin{array}{}
-4 \equiv +8 \quad (\text{mod 12}) \\
-5 \equiv +7 \quad (\text{mod 12})
\end{array}
$$

因此, 确定 "模" 之后, 可以找到与负数等价的正数 (正数为该负数的补数) 来代替负数, 使减法可以由加法运算实现.

得出如下结论:
- 负数可用其正补数代替, 正补数可以用模加上负数本身计算
- 正数和负数互为补数时, 二者的和为模数
- 正数的补数是其本身

补码的详细定义如下.

整数的补码定义为:

$$
[x]_{原} = 
\left\{
\begin{array}{ll}
0,x & 2^n>x\geq0\\
2^{n+1}+x & 0\geq x >-2^n \quad (\text{mod }2^{n+1})
\end{array}
\right.
$$

其中, $x$ 为真值, $n$ 为整数的位数.
例如:
- `+1010` 的补码为 `0,1010`
- `-1101` 的补码为 `1,0011`

小数的补码定义为:

$$
[x]_{原} = 
\left\{
\begin{array}{ll}
x & 1>x\geq0 \\
2+x & 0 > x \geq -1 \quad (\text{mod }2)
\end{array}
\right.
$$

其中, $x$ 为真值.
例如:
- `+0.1001` 的补码为 `0.1001`
- `-0.0110` 的补码为 `10.0000 - 0.0110 = 1.1010`

补码的 `0` 唯一表示为 `0.0000` , 补码比源码多一种 `-1` 的表示: `1.0000` .

根据补码定义, 也可以用补码求真值:
- `1.0101` 的真值为 `1.0101 - 10.0000 = -0.1011`
- `1,1110` 的真值为 `1,1110 - 100000 = -0010`
- `0.1101` 的真值为 `0.1101`

补码的引入是为了消除减法运算, 但根据补码定义, 在形成补码的过程中仍然有减法.

但是本质上, 计算补码的过程就是一个凑模的过程, 例如求 `-1011` 的补码.

$$
[x]_补 = 2 ^ {4+1} + x = 100000 - 1011 = 1,0101
$$

观察 `1011` 和 `0101` 实际是对 `1011` 每位取反后 `+1` .

同理, 由补码求反码也可以通过取反加 1 实现.


### 反码

反码通常用来作为原码求补码, 或补码求原码的中间过渡. 反码的定义如下.

整数的反码定义为:

$$
[x]_{原} = 
\left\{
\begin{array}{ll}
0,x & 2^n>x\geq0\\
(2^{n+1}-1)+x & 0\geq x >-2^n \quad (\text{mod }(2^{n+1}-1))
\end{array}
\right.
$$

其中, $x$ 为真值, $n$ 为整数的位数.
例如:
- `+1101` 的反码为 `0,1101`
- `-1101` 的反码为 `1,0010`

小数的反码定义为:

$$
[x]_{原} = 
\left\{
\begin{array}{ll}
x & 1>x\geq0 \\
(2-2^{-n})+x & 0 > x \geq -1 \quad (\text{mod }(2-2^{-n}))
\end{array}
\right.
$$

其中, $x$ 为真值.
例如:
- `+0.0110` 的反码为 `0.0110`
- `-0.0110` 的反码为 `1.1111 - 0.0110 = 1.1001`

反码的 `0` 有两种表示: `0.0000` 和 `1.1111`

综上所述, 三种机器码的特点为:
- 最高位均为符号位, 符号位和数值位之间用 `.` 或 `,` 隔开.
- 当真值为正时, 原码, 补码, 反码相同.
- 当真值为负时, 补码是原码的<font color=red><b>求反加</b></font> $\color{red}1$ , 反码是原码的<font color=red><b>每位求反</b></font>.

使用 8 位空间, 可以存储的各类机器码的值表对应如下:

$$
\begin{array}{|c|c|}
\hline
二进制码 & 
\begin{array}{}{\color{red}无符号数}\\对应真值\end{array} & 
\begin{array}{}{\color{red}原码}\\对应真值\end{array} & 
\begin{array}{}{\color{red}补码}\\对应真值\end{array} & 
\begin{array}{}{\color{red}反码}\\对应真值\end{array} \\
\hline
00000000 & 0 & +0 & \pm0 & +0 \\
\hline
00000001 & 1 & +1 & +1 & +1 \\
\hline
00000010 & 2 & +2 & +2 & +2 \\
\hline
\vdots & \vdots & \vdots & \vdots & \vdots \\
\hline
01111110 & 126 & +126 & +126 & +126 \\
\hline
01111111 & 127 & +127 & +127 & +127 \\
\hline
10000000 & 128 & -0 & -128 & -127 \\
\hline
10000001 & 129 & -1 & -127 & -126 \\
\hline
10000010 & 130 & -2 & -126 & -125 \\
\hline
\vdots & \vdots & \vdots & \vdots & \vdots \\
\hline
11111101 & 253 & -125 & -3 & -2 \\
\hline
11111110 & 254 & -126 & -2 & -1 \\
\hline
11111111 & 255 & -127 & -1 & -0 \\
\hline
\end{array}
$$

补码比原码和反码可以多表示一个负数.

进一步分析补码的设计理念.

对于正数的表达上限 $+127$ , 若此时再加正数, 理论上便会出现数据溢出, 因此, 即使不考虑编码, 有符号数便不能再加正数.
而对于负数, 才是补码真正的应用领域.
$+127$ 的原码为 `01111111` , 假设以 $+127-1$ 的计算为例, 目标结果是 $+126$ , 原码为 `01111110` .
为了设计成减法也可以用加法计算, 必须找到一个加数 $x$ , 使 `01111111` $+x=$ `01111110` .
由于加法只能进位, 因此发现 `11111111` 可以满足条件, 相加后结果为 `101111110` , 多出了 HSB 处的 $1$ , 使用取模的方式将其去除.
取模是让结果等于预期的善后手段, 而不是目的.


### 移码

在数字和数字进行比较的过程中, 由于表示符号的符号位是 `0` 代表正数, `1` 代表负数. 
在比较两数大小的时候不够直观. 因此诞生了移码.

移码的定义为:

$$
[x]_移 = 2^n + x \quad (2^n>x\geq-2^n)
$$

移码就是在真值上加 $2^n$ .
例如:
- `+10100` 的移码为 `100000 + 10100 = 1,10100`
- `-10100` 的移码为 `100000 - 10100 = 0,01100`

移码就是将补码的符号位翻转而已.

移码的计算必须通过加减完成, 与 `<<` 或 `>>` 之类的逻辑左右移完全无关.

称之为移码, 只是由于移码是数学上的几何平移, 通过移码可以将负数完全偏移到正数区间内, 便于辨识.


# 6.2 数的定点表示和浮点表示

## 定点表示

小数点固定在某一位置的数为定点数.

定点数只能表示纯整数或纯小数, 格式分别为:
- <font color=red><b>纯整数</b></font>: `± 数值 .`
- <font color=red><b>纯小数</b></font>: `± . 数值`

早期计算机通常只能处理一种数格式的运算, 分为单独的整数定点机和小数定点机.
- 整数定点机: 倾向于通用计算和数据处理, 只能处理纯整数.
- 小数定点机: 倾向于金融, 科学等大量小数运算的领域, 只能处理纯小数.

由于定点机的小数点位置固定, 因此处理非纯小数或纯整数的时候, 需要乘以比例因子.


## 浮点表示

实际计算机中的数据不一定是纯小数或纯整数, 而且数值的范围相差很大, 有极大的数和极小的数需要同时处理.
浮点数, 即小数点位置可以浮动的数.
通常, 浮点数被表示为:

$$
N = S \times r^{j}
$$
- $S$ 为<font color=red><b>尾数</b></font>, 可正可负.
- $j$ 为<font color=red><b>阶码</b></font>, 可正可负.
- $r$ 为<font color=red><b>基数</b></font>.

在计算机中, 基数可取 $2,4,8,16$ 等.

以基数 $r=2$ 为例, $N$ 可以写作:

$$
\begin{align}{}
N & = 11.0101 \\
& = 11.0101 \times 2^0 \\
& = 1.10101 \times 2^1 \\
& = 0.110101 \times 2^{10} \\
& =0.00110101 \times 2^{100} \\
& = 1101.01 \times 2^{-10}
\end{align}
$$

计算机中规定尾数必须用<font color=red><b>纯小数</b></font>的形式.
将尾数最高位为 $1$ 的浮点数称为<font color=red><b>规格化数</b></font>.

浮点数的表示形式为:

$$
\overset{阶码}{\overbrace{
\underset{阶符}{\underbrace{\begin{array}{|c|}\hline j_f \\ \hline\end{array}}}
\underset{阶码数值部分}{\underbrace{\begin{array}{|c|}\hline j_1j_2\cdots j_m\\ \hline\end{array}}}
}}
\overset{尾数}{\overbrace{
\underset{数符}{\underbrace{\begin{array}{|c|}\hline S_f \\ \hline\end{array}}}
\underset{尾数数值部分}{\underbrace{\begin{array}{|c|}\hline S_1S_2\cdots S_n\\ \hline\end{array}}}
}}
$$

浮点数由阶码和尾数两部分组成. 
阶码是整数, 阶符和 $m$ 位阶码共同反映浮点数的表示范围, 以及小数点的实际位置.
尾数是小数, 其位数 $n$ 反映浮点数的精度, 尾数数符代表浮点数的正负.

浮点数的**表示范围**为:

$$
\begin{align}
&正数: \quad 2^{-(2^m-1)}\times2^{-n} \sim 2^{(2^m-1)}\times(1-2^{-n}) \\
&负数: \quad -2^{(2^m-1)}\times(1-2^{-n}) \sim -2^{-(2^m-1)}\times2^{-n}
\end{align}
$$

当浮点数阶码大于最大阶码, 称为<font color=red><b>上溢</b></font>, 通常进行中断溢出处理.
当浮点数阶码小于最小阶码, 称为<font color=red><b>下溢</b></font>, 通常直接将尾数置零.

浮点数位数确定后, 合理分配阶码和尾数的位数, 直接影响到浮点数的表示范围和精度. 通常对于: 
- 短实数 (32-bit)
  阶码取 8 bit, 尾数取 24 bit
- 长实数 (64-bit)
  阶码取 11 bit, 尾数取 53 bit
- 临时实数 (80-bit)
  阶码取 15 bit, 尾数取 65 bit


为了提升浮点数的精度, 尾数必须进行规格化.

基数为 $2$ 时:
尾数最高位为 $1$ 的数为规格化数. 规格化时: 
- 向左规格化: 尾数左移 $1$ 位, 阶码减 $1$ .
- 向右规格化: 尾数右移 $1$ 位, 阶码加 $1$ .

经过规格化后, 浮点数的表示范围为:

$$
\begin{align}
&正数: \quad 2^{-(2^m-1)}\times2^{-1} \sim 2^{(2^m-1)}\times(1-2^{-n}) \\
&负数: \quad -2^{(2^m-1)}\times(1-2^{-1}) \sim -2^{-(2^m-1)}\times2^{-n}
\end{align}
$$

基数为 $4$ 时:
尾数最高两位不全为零的数为规格化数. 规格化时: 
- 向左规格化: 尾数左移 $2$ 位, 阶码减 $1$ .
- 向右规格化: 尾数右移 $2$ 位, 阶码加 $1$ .

基数为 $8$ 时:
尾数最高三位不全为零的数为规格化数. 规格化时: 
- 向左规格化: 尾数左移 $3$ 位, 阶码减 $1$ .
- 向右规格化: 尾数右移 $3$ 位, 阶码加 $1$ .

## 规格化与非规格化

规格化的目的是获得**最高的有效数字精度**, 以及**唯一的表示方式**.

理解规格化与非规格化区别的重点在于<font color=red><b>表示范围</b></font>和<font color=red><b>精度</b></font>.
- 规格化: **提升精度, 损失范围**
- 非规格化: **提升范围, 损失精度**

浮点数的精度使用<font color=red><b>相对精度</b></font>衡量, 相对精度指数字能被精确到其自身大小的比例.
相对精度通常由尾数位决定, 尾数位越多, 相对精度越高.
对于规格化数而言, 其相对精度是固定的, 且是最高的.

以 23-bit 尾数域举例:

|      |                              最小规格化数                               |                              最大非规格化数                              |                              最小非规格化数                               |
| :--: | :---------------------------------------------------------------: | :---------------------------------------------------------------: | :----------------------------------------------------------------: |
|  形式  | $\underset{\text{23-bit}}{\underbrace{1.0\cdots0}}\times2^{-126}$ | $\underset{\text{23-bit}}{\underbrace{0.1\cdots1}}\times2^{-126}$ | $\underset{\text{23-bit}}{\underbrace{0.0\cdots01}}\times2^{-126}$ |
| 有效位数 |                        24-bit (1-bit 隐含位)                         |                              23-bit                               |                               1-bit                                |
| 相对精度 |                         最高 ( $2^{-23}$ )                          |                               接近最高                                |                                 最低                                 |

最小的规格化数 $\approx 1.175\times 10^{-38}$ 仍然拥有 24-bit 有效数字.
最小的非规格化数 $\approx1.4\times 10^{-45}$ 虽然更小, 但仅有 1-bit 有效数字.

非规格化牺牲了精度, 换取可以表示更接近 $0$ 的表示范围.
非规格化可以实现**渐进式下溢**, 填补了最小规格化数和 $0$ 之间的空隙, 使浮点数在接近 $0$ 时能够平滑过渡, 而不是**突然下溢**.

## 举例

> 将十进制数 $+\dfrac{13}{128}$ 改写, 浮点数字长 16-bit, 阶码 5-bit, 尾数 11-bit.

二进制形式为: `0.0001101`  
16-bit 字长定点数表示为: `0.000110100000000`  
在定点机中, $[x]_原 = [x]_{补} = [x]_反 =$ `0.000110100000000`  

其规格化表示为: $x=$ `0.1101` $\times 2^{-11}$  
浮点表示为:  
- 原码: `1,0011;0.1101000000`
- 补码: `1,1101;0.1101000000`
- 反码: `1,1100;0.1101000000`


> 将十进制数 $-54$ 改写, 浮点数字长 16-bit, 阶码 5-bit, 尾数 11-bit.

二进制形式为: `-110110`
定点表示为:
- 原码: `1,000000000110110`
- 补码: `1,111111111001010`
- 反码: `1,111111111001001`

其规格化表示为: `-0.11011` $\times 2^{110}$  
浮点表示为:
- 原码: `0,0110;1,1101100000`
- 补码: `0,0110;1,0010100000`
- 反码: `0,0110;1,0010011111`

注意, 纯整数补零向前补, 纯小数补零向后补.


## IEEE 754

IEEE二进制浮点数算术标准 (IEEE 754) 时最广泛使用的浮点数运算标准.
该标准定义了浮点数的格式, 反常值, 无穷, 非数值.
标准还定义了浮点数运算符, 4 种浮点数摄入规则, 5 种例外状况.

浮点数表示为:

$$
\text{Value} = \text{sign} \times \text{exponent} \times \text{fraction}
$$

即浮点数的实际值, 等于符号位, 乘以指数偏移值, 乘以分数值.

IEEE 754 的浮点数整体形式表现为:

$$
\begin{array}{|c|c|}
\hline
数符 & 
指数部分(移码) & 
分数值(原码) \\
\hline
\end{array}

$$

小数点位于阶码和尾数之间, 数符提至 HSB 处.

分数值部分在非规格化表示时默认为 $0$ , 其余情况下全部默认为 $1$ .


### 指数偏移值 (Exponent Bias)

即浮点数表示法中指数域的编码值, 等于指数的实际值 + 某个固定值. IEEE 754 标准规定的固定值为 $2^{e-1}-1$ , 其中 $e$ 为存储指数的比特长度.

以单精度浮点数为例, 其指数域为 8-bit, 固定偏移值为 $2^{8-1}-1=127$ . 单精度浮点数的指数部分实际取值范围为 $-126\sim127$ , 另外的 $-127$ 和 $128$ 被用作特殊处理 (非规格化表示, 特殊值).

例如指数实际值为 $17_{10}$ , 则在单精度浮点数中的指数域编码值为 $17_{10}+127_{10}=144_{10}$ .

IEEE 754 的指数部分实际是一种特殊偏移量的移码.
移码的核心作用是将负数全部偏移到正数区间, 方便直观观察大小.

- $e=0$ 即全 $0$ 编码, 用于表示**非规格化数**和 $0$ .
- $e=255$ 即全 $1$ 编码, 用于表示无穷大 $\pm\infty$ 和非数 $\text{NaN}$ .


### 规约形式的浮点数

即规格化, 该表示下, 尾数有 1-bit 的隐含二进制有效数字, 称为有效数.


### 非规约形式的浮点数

即非规格化, 通常是在某个数字非常接近于 $0$ 时, 才会使用非规格化表示.
非规格化浮点数的指数偏移值比规格化的偏移值小 $1$ . 
例如在 8-bit 指数域的条件下:
- 最小规格化的单精度浮点指数部分编码值为 $1$ , 指数实际值为 $-126$ .
- 非规格化的单精度浮点指数部分编码值为 $0$ , 指数实际值也为 $-126$ .


### 特殊值

IEEE 754 的 3 种特殊值为:
- $\pm 0$ : 指数为 $0$ , 尾数的小数部分也为 $0$ , 即全 $0$ .
- $\pm\infty$ : 指数为 $2^{e}-1$ , 且尾数的小数部分为 $0$ . 正负取决于符号位.
- $\text{NaN}$ : 指数为 $2^{e}-1$ , 且尾数的小数部分为非零.


总结如下

$$
\begin{array}{|c|c|}
\hline
含义 & 指数 & 小数 \\
\hline
0 & 0 & 0 \\
\hline
非规约形式 & 0 & 大于0,小于1 \\
\hline
规约形式 & 1\sim 2^e-2 & 大于等于1, 小于2 \\
\hline
\pm\infty & 2^e-1 & 0 \\
\hline
\text{NaN} & 2^e-1 & 非0 \\
\hline
\end{array}
$$

注意, $2^e$ 与上文的 $2^{e-1}$ 不同, 此处为编码值, 而不是原始值.


# 6.3 定点运算

定点运算包括移位, 加, 减, 乘, 除.

## 移位运算

有符号数的移位称之为<font color=red><b>算数移位</b></font>, 无符号数的移位称之为<font color=red><b>逻辑移位</b></font>.

计算机中的小数点位置是事先约定的, 因此, 二进制表示的机器数进行 $n$ 位左移或右移时, 其本质为将原数乘以或除以 $2^n$ .

算数移位规则

符号位不随移位改变.

对于正数, $[x]_原 = [x]_补 = [x]_反 = 真值$ , 因此移位后出现的空位使用 $0$ 填充.
对于负数, 原码, 补码, 反码的表示形式不同, 因此移位后填补规则不同. 

$$
\begin{array}{|c|c|}
\hline
码制 & 填补规则 \\
\hline
原码 & 0 \\
\hline
补码 & 左移添0, \ 右移添1 \\
\hline
反码 & 1 \\
\hline
\end{array}
$$

观察补码可以发现, 对于从 LSB 到 HSB 方向上的第一个 $1$ : 
- 其左侧位数与反码相同
- 其右侧位数 (包括第一个 $1$ ) 与原码相同

例如:
- 原码: `1,1010100`
- 反码: `1,0101011`
- 补码: `1,0101100`

因此是 "左移添 $0$ , 右移添 $1$ " , 因为移位要与原码一致. 
- 左移时, 原码右侧添加了新 $0$ , 对应补码也应当添 $0$ .
- 右移时, 原码左侧添加了新 $0$ , 对应反码添加了新 $1$ , 对应补码也应当添 $1$ .

对于逻辑移位:
- 逻辑左移位时, 高位丢弃, 低位添 $0$ .
- 逻辑右移位时, 低位丢弃, 高位添 $0$ .

区别于算数移位, 对于逻辑移位, 首位的 $1$ 并不是代表负数的数符, 而是作为普通值处理.


### 桶形移位器

移位具体是通过<font color=red><b>桶型移位器</b></font> (barrel shifter) 的逻辑电路实现的. 桶形移位器非常高效, 可以在一个时钟周期内, 完成任意位数的移位操作.

构成移位器的基础元件为<font color=red><b>多路选择器</b></font> (Multiplexer, MUX) . 其基本功能为: 从多个输入信号中, 选择一个信号作为输出.

一个 $2^n$ 选 $1$ 的多路选择器由如下部分组成:

$$
\begin{array}{|c|c|}
\hline
名称 & 数量 & 作用 \\
\hline
数据输入端 (I_0,I_1,\cdots) & 2^n & 接受待选择的数据 \\
\hline
选择控制端 (S_0,S_1,\cdots) & n & 选择控制信号输入 \\
\hline
数据输出端 (Y) & 1 & 输出选择的数据 \\
\hline
\end{array}
$$

以 $2$ 选 $1$ MUX 为例:
有两个数据输入端 $I_0,I_1,\cdots$ , 和一个输出端 $S$ .
其真值表为:

$$
\begin{array}{|c|c|}
\hline
选择控制端(S) & 输出(Y) \\
\hline
0 & I_0 \\
\hline
1 & I_1 \\
\hline
\end{array}
$$

其布尔函数为:

$$
Y = \bar{S}\cdot I_0 + S\cdot I_1
$$

可以通过基本逻辑门实现.

移位操作的本质是将数据的每一位移动到新的位置. 可以使用 MUX 控制每一位数据时保持原位, 还是移动到其左边或右边的相邻位置.

以 $4$ 位数据的 $1$ 位循环左移移位器为例:
- 输入数据为: $D_3 D_2 D_1 D_0$
- 预期输出为: $D_2 D_1 D_0 D_3$

为此需要 4 个 $2$ 选 $1$ MUX, 每个 MUX 负责计算输出结果的 $1$ 位 $O_i$ .

$$
\begin{array}{|c|c|}
\hline
输出位(O_i) & \text{2选1 MUX功能} \\
\hline
O_0 & 选择 D_0或D_1\\
\hline
O_1 & 选择 D_1或D_2\\
\hline
O_2 & 选择 D_2或D_3\\
\hline
O_3 & 选择 D_3或D_0\\
\hline
\end{array}
$$

该逻辑电路可以使用一个控制信号 $S$ 进行控制:
- $S=0$ 保持, 输出 $O_i = D_i$
- $S=1$ 左移 $1$ 位, 输出 $O_i = D_{(i+1)(\text{mod 4})}$ 

实现任意 $N$ 位移位器, 需要使用分层级联结构.

若构建一个 $8$ 位移位器, 则需要 $n=\log_{2}8=3$ 个逻辑层.
1. 第 1 层 (1 位移位)
	- 功能: 实现 $0$ 位或 $1$ 位移位.
	- 控制: 移位控制信号 $S_0$ 控制.
	- 实现: 8 个 $2$ 选 $1$ MUX, 若 $S_0=1$ 则移 $1$ 位, 若 $S_0=0$ 则数据保持不动.
2. 第 2 层 (2 位移位)
	- 功能: 实现 $0$ 位或 $2$ 位移位.
	- 控制: 移位控制信号 $S_1$ 控制.
	- 实现: 8 个 $2$ 选 $1$ MUX, 以前一层的输出为输入, 若 $S_1=1$ 则再移 $2$ 位, 若 $S_1=0$ 则数据保持不动.
3. 第 3 层 (4 位移位)
	- 功能: 实现 $0$ 位或 $4$ 位移位.
	- 控制: 移位控制信号 $S_2$ 控制.
	- 实现: 8 个 $2$ 选 $1$ MUX, 以前一层的输出为输入, 若 $S_2=1$ 则再移 $4$ 位, 若 $S_1=0$ 则数据保持不动.


## 加减运算

减法可以看做加减数的负值, 因此加减合并讨论. 现代计算机中采用补码做加减运算.

补码加法运算的基本公式为:

$$
\begin{array}{ll}
整数: & [A]_补 + [B]_补 = [A+B]_补 (\text{mod }2^{n+1}) \\
小数: & [A]_补 + [B]_补 = [A+B]_补 (\text{mod }2)
\end{array}
$$

即整数计算后, 丢弃超出范围的位; 小数计算后, 丢弃整数部分超出符号位的位.

取模的过程是补码运算的核心. 使用补码的意义在于将减法推向和加法相同的叠加方向, 利用循环获得减法的结果.

由于补码的加法特性, 因此实际上, 加减计算中的取模操作本质上就是扔掉最高位, 将数值重新拉回有效范围的手段.

<font color=red><b>溢出判断</b></font>

在加减法计算过程中, 由于减法计算造成的进位, 并用取模丢弃最高位是预期的设计. 
但是除此之外, 还存在相加或相减时造成进位的情况, 此时若丢弃最高位, 结果是非预期设计的错误值, 因此需要进行溢出判断.

溢出判断有两种方式: 观察最高位进位法, 双符号位法

**观察最高位进位法**:

- 对于加法, 仅在正数+正数, 负数+负数这两种情况下才可能溢出, 不同符号的两数相加不会溢出.
- 对于减法, 仅在正数-负数, 负数-正数这两种情况下才可能溢出, 不同符号的两数相减不会溢出.

由于减法计算也是用过加法实现的, 因此只需要做如下判断:

> 若两个操作数符号相同, 结果与操作数的符号不同, 即为溢出.


**双符号位法**:

使用双符号位存储符号时, 真值需要通过模 4 计算, 丢弃最高的两位符号位.
双符号位用 `00` 代表正数, 用 `11` 代表负数.
在做加法计算时, 若计算结果的两个符号位不相等, 则发生溢出.
- 符号位 `01` 代表正溢出
- 符号位 `10` 代表负溢出

双符号位损失存储精度, 实际不常用.


## 乘法运算

### 真值乘法

首先分析笔算乘法的过程, 两数相乘的结果符号通过正正得正等获得.

例如 $A=0.1101$ 和 $B=0.1011$ . 二者数值部分的计算过程如下:

$$
\begin{array}{r}
\texttt{0.1101}\\
\times\ \texttt{0.1011} \\
\hline
\texttt{1101} \\
\texttt{1101 } \\
\texttt{0000{ } } \\
\texttt{1101{ }{ } } \\
\hline
\texttt{0.10001111}
\end{array}\ 
\begin{array}{lc}
\\
\\
\cdots\cdots A\times 2^0 & A 不移位 \\
\cdots\cdots A\times 2^1 & A 左移1位 \\
\cdots\cdots 0\times 2^2 & 0 左移2位 \\
\cdots\cdots A\times 2^3 & A 左移3位 \\
\\
\end{array}
$$

因此 $A\times B = +0.10001111$ .

上述过程中包含多次左移, 以及对 4 次位积的相加运算.

改进的笔算过程如下:

$$
\begin{align}
A\times B &= A\times0.{\color{red}1}{\color{orange}0}{\color{green}1}{\color{blue}1} \\
&=0.{\color{red}1}A+0.0{\color{orange}0}A+0.00{\color{green}1}A+0.000{\color{blue}1}A \\
&=0.{\color{red}1}A+0.0{\color{orange}0}A+0.00{\color{green}1}(A+0.{\color{blue}1}A) \\
&=0.{\color{red}1}A + 0.0{\color{orange}1}[{\color{orange}0}A + 0.{\color{green}1}(A+0.{\color{blue}1}A)] \\
&=0.{\color{red}1}\{A + 0.{\color{orange}1}[{\color{orange}0}A + 0.{\color{green}1}(A+0.{\color{blue}1}A)]\} \\
&={\color{red}2^{-1}}\{A+{\color{orange}2^{-1}}[0A+{\color{green}2^{-1}}(A+{\color{blue}2^{-1}}A)]\} \\
&={\color{red}2^{-1}}\{A+{\color{orange}2^{-1}}[0A+{\color{green}2^{-1}}(A+{\color{blue}2^{-1}}(A+0))]\}
\end{align}
$$

上述过程可以视作移位和加法两种运算.

假设最初状态的<font color=red><b>部分积</b></font>为 `0` , 分步计算的过程如下:

$$
\begin{array}{c|lr}
1 & {\color{blue}1}\times 被乘数+部分积\ (0) & A+0=0.1101+0.0000=0.1101 \\
2 & 右移1位,得到新部分积 & 2^{-1}(A+0) = 0.01101 \\
3 & {\color{green}1}\times被乘数+部分积 & A+2^{-1}(A+0) = 0.1101+0.01101=1.00111 \\
4 & 右移1位,得到新部分积 & 2^{-1}[A+2^{-1}(A+0)] = 0.100111 \\
5 & {\color{orange}0}\times被乘数 + 部分积 & 0\times A+2^{-1}[A+2^{-1}(A+0)] = 0.100111 \\
6 & 右移1位,得到新部分积 & 2^{-1}\{A+2^{-1}[A+2^{-1}(A+0)]\} = 0.0100111 \\
7 & {\color{red}1}\times被乘数 + 部分积 & A+2^{-1}\{A+2^{-1}[A+2^{-1}(A+0)]\} = 1.0001111 \\
8 & 右移1位,得到新部分积 & 2^{-1}\{A+2^{-1}\{A+2^{-1}[A+2^{-1}(A+0)]\}\} = 0.10001111
\end{array}
$$

实际使用一个寄存器存放被乘数, 一个寄存器存放乘积的高维, 另一个寄存器存放乘数以及乘积的低位.


### 原码乘法

原码乘法与真值乘法仅差符号位, 符号位通过异或求得, 再加上数值即可.

> 例如: 已知 $x=-0.1110$ , $y=-0.1101$ , 求 $[x\cdot y]_原$

符号位 $1\oplus 1 =0$ .

数值部分计算过程为:
1. `0.1110 × 1 = 0.1110` 
2. `0.1110` 右移 $1$ 位得到 `0.01110` , `0.01110 + (0.1110 × 0) = 0.01110`
3. `0.01110` 右移 $1$ 位得到 `0.001110` , `0.001110 + (0.1110 × 1) = 1.000110`
4. `1.000110` 右移 $1$ 位得到 `0.1000110` , `0.1000110 + (0.1110 × 1) = 1.0110110`
5. `1.0110110` 右移 $1$ 位得到 `0.10110110` .

本质上移位的过程和笔算过程是相同的, 不过是换成一种计算机更容易理解的表述.

为了提升运算速度, 可以使用<font color=red><b>原码两位乘</b></font>进行计算.
原码两位乘使用两位乘数计算新的部分积, 两位乘数的各个情况分别对应如下操作:

$$
\begin{array}{|c|c|}
\hline
乘数y_{n-1}y_n & 新的部分积 \\
\hline
00 & 新部分积=(原部分积 + 0 \times被乘数) >> 2 \\
\hline
01 & 新部分积=(原部分积 + 1 \times被乘数) >> 2 \\
\hline
10 & 新部分积=(原部分积 + 2 \times被乘数) >> 2 \\
\hline
11 & 新部分积=(原部分积 + 3 \times被乘数) >> 2 \\
\hline
\end{array}
$$

可以通过十进制乘法进行理解, 例如 $1123\times1111=1247653$ :

$$
\begin{array}{r}
\texttt{1123} \\
\texttt{× 1111} \\
\hline
\texttt{12353} \\
\texttt{12353{ }{ }} \\
\hline
\texttt{1247653}
\end{array}
$$

相当于一次性计算了被乘数 (1123) 与乘数 (1111) 两位的计算结果. 由于一次性计算了两位, 因此移位也需要一次移 2 位.

对于原码两位乘, $2\times被乘数$ 可以通过左移 $1$ 位实现, 但 $3\times被乘数$ 比较难以实现.
通常将 $3\times被乘数$ 视为 $(4-1)\times被乘数$ , 通过先减 $1\times被乘数$ 再加 $4\times被乘数$ .

上述过程涉及到**部分积的存储架构**. 部分积通常由两个主要的寄存器存储: 
- 累加器 (Accumulator, ACC) 存储高位部分积, 存储当前迭代的最高位结果, 以及所有累加操作的结果.
- 乘商寄存器 (Multiplier-Quotient Register, MQ) 存储低位部分积, 初始存储乘数, 在迭代过程逐渐存储结果的低位部分.

以上两个寄存器连接, 形成一个双倍字长的寄存器, 用于存储最终乘积.

$$
最终乘积=[ACC]|[MQ]
$$

进行 $-1\times被乘数$ 是在高位寄存器, 即 ACC 中进行的, 这是因为 ACC 寄存器有 ALU 单元, 是加减, 累加的唯一发生位置, 而 MQ 不具备 ALU 功能.

以一个实际案例说明:

> 设 $x=\texttt{0.111111}$ , $y=\texttt{-0.111001}$ , 使用原码二位乘求 $[x\cdot y]_{原}$

解:

- $[-x]_补 = \texttt{1.000001}$ 
- $2x = \texttt{1.111110}$ (临时溢出, 中间结果, 不能独立解释, 需要移位) 
- $|y|=\texttt{0.111001}$

首先演示笔算的原码二位乘:

$$
\begin{array}{r}
\texttt{0.111111} \\
\texttt{× 0.{\color{blue}11}{\color{green}10}{\color{red}01}} \\
\hline
\color{red}\texttt{111111} \\
\color{green}\texttt{1111110{ }{ }} \\
\color{blue}\texttt{10111101{ }{ }{ }{ }} \\
\hline
\texttt{0.111000000111}
\end{array}
$$

再加上符号位, 得到结果 $\texttt{1.111000000111}$ .

下面演示计算机计算过程:

设原始部分积为 $\texttt{000.000000}$ , 原始乘数为 $\texttt{0.{\color{blue}11}{\color{green}10}{\color{red}01}}$

第一次计算:
观察乘数的低端两位, 值为 $\texttt{\color{red}01}$ , 因此:

$$
新部分积 = 原部分积 + 1\times被乘数
$$

得到新的部分积为:

$$
\texttt{000.000000+{\color{red}01}*000.111111=0.000000+{\color{red}000.111111}=000.111111}
$$

第二次计算:
首先应当将原部分积右移 $2$ 位, 以便与新结果相加:

$$
\texttt{000.111111>>2=000.001111|11(MQ)}
$$

为了优化存储空间, 在上一步计算中, 低端两位的 $\texttt{\color{red}01}$ 已经使用, 因此可以右移移除, 而将原部分积因为右移多出原本寄存器长度的两位 $\texttt{11}$ 存入乘数寄存器中.  
乘商寄存器中仅保留 $\texttt{000.001111}$ .

观察乘数的中部两位, 值为 $\texttt{\color{green}10}$ , 因此:

$$
新部分积 = 原部分积 + 2\times被乘数
$$

得到新的部分积为:

$$
\texttt{000.001111+{\color{green}10}*000.111111=000.001111+{\color{green}001.111110}=010.001101|11(MQ)}
$$

第三次计算:
将原部分积右移 $2$ 位, 以便与新结果相加:

$$
\texttt{010.001101|11(MQ)>>2=000.100011|0111(MQ)}
$$

观察乘数的高端两位, 值为 $\texttt{\color{blue}11}$ , 因此:

$$
新部分积 = 原部分积 + (-1)\times被乘数 + 4\times被乘数
$$

首先计算 $原部分积 + (-1)\times被乘数$ :

$$
\texttt{000.100011+111.000001=111.100100|0111(MQ)}
$$

之后有两种选择:
- 先 $+4\times被乘数$ , 再右移 $2$ 位
- 先右移 $2$ 位, 再 $+4\times被乘数$

为了与其他情况统一, 都按照先加某倍被乘数, 再右移, 因此此处也先进行右移.

将上步计算得到的新部分积进行右移 $2$ 位:

$$
\texttt{111.100100|0111(MQ)>>2=111.111001|000111(MQ)}
$$

再进行 $中间部分积 + 4\times被乘数$ :

$$
\texttt{111.111001+000.111111=000.111000|000111(MQ)}
$$

注意, 此处直接加 $\texttt{000.111111}$ , 而没有加 $\texttt{4*000.111111}$ 这是因为之前已经先进行了移位操作, 此时不能再进行乘 4 操作.

最终得到的结果为 $\texttt{000.111000000111}$ 加上符号位后, 结果为 $\texttt{1.111000000111}$ .

过程中有以下几个重点内容:

**被乘数的小数点前有 $3$ 位, 而不是常见 $1$ 位符号位**:  
这是因为在乘法运算过程中, 需要有过渡的中间临时溢出结果, 而后续需要进行右移才能获得正确的内容, 为了确保右移的正确性, 需要在前面补充对应的位数.
例如对于二位乘, 每次计算结果都需要右移 $2$ 位, 在右移 $2$ 位后, 还要获得正确的符号为, 因此需要在小数点前补充 $3$ 位.

**$+3\times被乘数$ 的处理方式:**
之所以使用 $+3\times被乘数$ 的处理方式, 是因为这样可以规范化整个运算过程, 而不用额外的在一次计算中涉及另外的一次乘法计算, 这对其他优化算法有重要的意义, 比如 Booth 计算. 对于后续的效率提升有极大作用.

<font color=red><b>额外标记位</b></font>
可以观察到, 对于乘数中的 $\texttt{11}$ 部分, 人类可以正确的识别, 并知道应该拆成两步进行计算, 但是计算机需要更明确, 更直白的算法才能理解需要进行哪些动作.
基于此, 会拆出额外的1位标记位 $C_j$ , 用这个标记位来判断是否触发了 $\texttt{11}$ 的乘数部分, 并进行对应操作. 对应的运算规则为:

$$
\begin{array}{|c|c|}
\hline
乘数两位 & 标记位 C_j & 对应操作 \\
\hline
00 & 0 & 部分和+0\times被乘数后右移两位, 乘数右移两位, C_j不变 \\
\hline
01 & 0 & 部分和+1\times被乘数后右移两位, 乘数右移两位, C_j不变 \\
\hline
10 & 0 & 部分和+2\times被乘数后右移两位, 乘数右移两位, C_j不变 \\
\hline
11 & 0 & 部分和-1\times被乘数后右移两位, 乘数右移两位, C_j置\ 1 \\
\hline
00 & 1 & 部分和+1\times被乘数后右移两位, 乘数右移两位, C_j置\ 0 \\
\hline
01 & 1 & 部分和+2\times被乘数后右移两位, 乘数右移两位, C_j置\ 0 \\
\hline
10 & 1 & 部分和-1\times被乘数后右移两位, 乘数右移两位, C_j置\ 1 \\
\hline
11 & 1 & 部分和+0\times被乘数后右移两位, 乘数右移两位, C_j置\ 1 \\
\hline
\end{array}
$$

通过乘数的两位与标记位组成的 3-bit 命令, 可以确定某次的运算需要如何进行.

为了能够正确的组成 3-bit 命令, 需要在乘数的最前面添加一对 $\texttt{00}$ 这样可以保证能够和 $C_j$ 组成最后一次的命令.

将上文题目重新按 3-bit 命令重新梳理, 将右移放到每次操作的后面:

$$
\begin{array}{|c|c|}
\hline
部分积 & 乘数 & C_j & 命令码 & 说明 \\
\hline
\begin{array}{r}\texttt{ 000.000000}\end{array} & \texttt{|001110{\color{red}01}} & \texttt{0} & \texttt{010} & 初始状态 \\
\hline
\begin{array}{r}
\texttt{000.000000} \\
\texttt{+000.111111} \\
\texttt{=000.111111} \\
\texttt{>>2} \\
\texttt{000.001111}
\end{array} &
\texttt{11|0011{\color{red}10}} & \texttt{0} & \texttt{100} & 
\begin{array}{}根据\texttt{010}计算\end{array} \\
\hline
\begin{array}{r}
\texttt{000.001111} \\
\texttt{+001.111110} \\
\texttt{=010.001101} \\
\texttt{>>2} \\
\texttt{000.100011}
\end{array} &
\texttt{0111|00{\color{red}11}} & \texttt{0} & \texttt{110} & 
\begin{array}{}根据\texttt{100}计算\end{array}\\
\hline
\begin{array}{r}
\texttt{000.100011} \\
\texttt{+111.000001} \\
\texttt{=111.100100} \\
\texttt{>>2} \\
\texttt{111.111001}
\end{array} &
\texttt{000111|{\color{red}00}} & \texttt{1} & \texttt{001} & 
\begin{array}{}根据\texttt{110}计算 \\ C_j置\ 1\end{array} \\
\hline
\begin{array}{r}
\texttt{111.111001} \\
\texttt{+000.111111} \\
\texttt{=000.111000} \\
\end{array} &
\texttt{000111|00} & \texttt{0} & \texttt{000} & 
\begin{array}{}根据\texttt{001}计算 \\ 计算完成 \end{array} \\
\hline
\end{array}
$$


为了简化设计, 在定点系统中的乘法运算通常就是**纯整数乘法**, 或**纯小数乘法**, 这样可以避免溢出. 
这是因为两个纯小数相乘结果还是纯小数, 不会有整数位的部分, 也就不会产生溢出.


### 补码乘法

为了提升效率, 一些机器直接使用补码做乘法.

<font color=red><b>校正法</b></font>

计算 $[x]_补\cdot [y]_补$ 时, 是将 $[y]_补$ 按位进行拆分, 然后移位后求和进行计算. 

对于 $[y]_补$ 为正时:

$$
[x\cdot y]_补 = [x]_补\cdot y = [x]_补\cdot [y]_原
$$

可以按照原码乘法的规则计算.

对于 $[y]_补$ 为负时:

$$
[x\cdot y]_补 = [x]_补\cdot [-y]_原 + [-x]_补
$$

即按照正的 $[y]_补$ 计算结果后加上 $[-x]_补$ 进行校正.

推导过程为:

被乘数 $x$ 符号任意, 乘数 $y$ 符号为负.
- $[x]_补 = x_0.x_1x_2\cdots x_n$
- $[y]_补 = 1.y_1y_2\cdots y_n$

对于真值 $y$ 有 $[y]_补 = (y+2)(\text{mod 2})$ 

由于 $y<0$ , 因此有:

$$
\begin{align}
y &= [y]_补-2 \\
&= 1.y_1y_2\cdots y_n - 2 \\
&= 0.y_1y_2\cdots y_n - 1
\end{align}
$$

则:

$$
\begin{align}
x\cdot y &= x(0.y_1y_2\cdots y_n - 1) \\
&=x\cdot (0.y_1y_2\cdots y_n) - x
\end{align}
$$

因此有:

$$
[x\cdot y]_补 = [x\cdot (0.y_1y_2\cdots y_n)]_补 + [-x]_补
$$

例:

> 设 $[x]_补=\texttt{1.0101}$ , $[y]_补=\texttt{0.1101}$ , 使用补码一位乘求 $[x\cdot y]_{补}$

解:

乘数 $[y]_补$ 为正, 为了方便与原码计算进行对照, 写出被乘数与乘数的原码:
- $[x]_原 = \texttt{1.1011}$
- $[y]_原 = \texttt{0.1101}$

$$
\begin{array}{|c|c|}
\hline
原码计算 & 补码计算 & 说明 \\
\hline
\texttt{0.1011×0.1101} & \texttt{1.0101×0.1101}\\
\hline
\begin{array}{r}
\texttt{0.1011} \\
\texttt{×0.1101} \\
\hline
\texttt{1011} \\
\texttt{1011{ }{ }} \\
\hline
\texttt{110111} \\
\texttt{1011{ }{ }{ }} \\
\hline
\texttt{0.10001111}
\end{array} & 
\begin{array}{r}
\texttt{1.0101} \\
\texttt{×0.1101} \\
\hline
\texttt{1110101} \\
\texttt{10101{ }{ }} \\
\hline
\texttt{11001001} \\
\texttt{10101{ }{ }{ }} \\
\hline
\texttt{1.01110001}
\end{array} &
\begin{array}{c}
\texttt{ } \\
\texttt{ } \\
\texttt{ } \\
\texttt{} \\
此处二者相等\\
\texttt{ } \\
结果相等
\end{array}\\
\hline
\end{array}
$$

可以观察到, 使用补码进行计算时, 前面补位应该用 $\texttt{1}$ 而不是 $\texttt{0}$ .

此时不同位对应的补码值也可以直接进行相加, 可以得到正确的结果. 
因为乘数的每位都是数值位, 将其分开思考, 被乘数分别乘以 
- $\texttt{0.0001}$ 
- $\texttt{0.01}$ 
- $\texttt{0.1}$ 
这些乘法本质上仅是移位操作, 因此是正确的.
而将上述的乘积相加起来, 又是符合补码加法的, 因此也是正确的.
因此补码乘法在上述案例中可以直接按照原码乘法的计算方法进行.


例:

> 设 $[x]_补=\texttt{0.1101}$ , $[y]_补=\texttt{1.0101}$ , 使用补码一位乘求 $[x\cdot y]_{补}$

解:

乘数 $[y]_补$ 为负, 为了方便与原码计算进行对照, 写出被乘数与乘数的原码:
- $[x]_原 = \texttt{0.1101}$
- $[y]_原 = \texttt{1.1011}$

- $[-x]_补 = \texttt{1.0011}$

$$
\begin{array}{|c|c|}
\hline
原码计算 & 补码计算 \\
\hline
\texttt{0.1101×1.1011} & \texttt{0.1101×1.0101}\\
\hline
\begin{array}{r}
\texttt{0.1101} \\
\texttt{×0.1011} \\
\hline
\texttt{1101} \\
\texttt{1101{ }} \\
\hline
\texttt{100111} \\
\texttt{1101{ }{ }{ }} \\
\hline
\texttt{0.10001111}\\
\hline
\texttt{1.01110001}
\end{array} & 
\begin{array}{r}
\texttt{0.1101} \\
\texttt{×0.0101} \\
\hline
\texttt{1101} \\
\texttt{1101{ }{ }} \\
\hline
\texttt{0.01000001} \\
\texttt{+1.0011{ }{ }{ }{ }} \\
\hline
\texttt{1.01110001} \\
\texttt{}
\end{array}\\
\hline
\end{array}
$$

上述方法中, 结果的符号位是在运算过程中产生的, 而不是像原码计算一样是后续添加的.

校正法与乘数的符号有关, 实现较为麻烦, 若不考虑操作数符号, 可以使用比较法.

<font color=red><b>比较法 (Booth算法)</b></font>

推导过程如下:

设:
- $[x]_补 = x_0.x_1x_2\cdots x_n$
- $[y]_补=y_0.y_1y_2\cdots y_n$

按照校正法的规则, 补码乘法公式为:

$$
[x\cdot y]_补 = [x]_补(0.y_1y_2\cdots y_n) - [x]_补\cdot y_0
$$

当 $y_0=0$ 时, 乘数 $y$ 为正, 无需校正:

$$
[x\cdot y]_补 = [x]_补(0.y_1y_2\cdots y_n)
$$

当 $y_0=1$ 时, 乘数 $y$ 为负, 需要校正:

$$
[x\cdot y]_补 = [x]_补(0.y_1y_2\cdots y_n) - [x]_补
$$

在 $\text{mod 2}$ 前提下, $[-x]_补=-[x]_补$ .

$$
\begin{align}
[x\cdot y]_补
&=[x]_补(y_{1}2^{-1}+y_{2}2^{-2}+\cdots+y_{n}2^{-n}) - [x]_补\cdot y_0 \\
&=[x]_补(-y_0+y_{1}2^{-1}+y_{2}2^{-2}+\cdots+y_{n}2^{-n}) \\
&=[x]_补[-y_0+(y_{1}-y_{1}2^{-1})+(y_{2}-y_{2}2^{-2})+\cdots+(y_{n}-y_{n}2^{-n})] \\
&=[x]_补[(y_{1}-y_{0})+(y_{2}-y_{1})2^{-1}+\cdots+(y_{n}-y_{n-1})2^{-(n-1)}+(0-y_{n})2^{-n}] \\
&=[x]_补[(y_{1}-y_{0})+(y_{2}-y_{1})2^{-1}+\cdots+(y_{n+1}-y_{n})2^{-n}]
\end{align}
$$

其中, $y_{n+1}=0$ .

由此可以得到递推公式:

$$
\begin{array}{l}
[z_0]_补 = 0 \\
[z_1]_补 = 2^{-1}\{[z_0]_补 + (y_{n+1}-y_{n})[x]_补\} \\
[z_2]_补 = 2^{-1}\{[z_1]_补 + (y_{n}-y_{n-1})[x]_补\} \\
\ \ \ \qquad\vdots \\
[z_i]_补 = 2^{-1}\{[z_{i-1}]_补 + (y_{n-i+2}-y_{n-i+1})[x]_补\} \\
\ \ \ \qquad\vdots \\
[z_n]_补 = 2^{-1}\{[z_{n-1}]_补 + (y_{2}-y_{1})[x]_补\} \\
[x\cdot y]_补 = [z_{n+1}]_补 = [z_n]_补+(y_1-y_0)[x]_补
\end{array}
$$

由此可见, 乘积可以通过递推公式得出, $y_{i+1}-y_{i}$ 的差恰好为乘数的最后两位的对应状态.

$$
\begin{array}{|c|c|}
\hline
y_{i}y_{i+1} & y_{i+1}-y_{i} & 操作 \\
\hline
\texttt{00} & \texttt{0} & 部分积右移1位 \\
\hline
\texttt{01} & \texttt{1} & 部分积+[x]_补,再右移1位 \\
\hline
\texttt{10} & \texttt{-1} & 部分积+[-x]_补,再右移1位 \\
\hline
\texttt{11} & \texttt{0} & 部分积右移1位 \\
\hline
\end{array}
$$

例:

> 设 $[x]_补=\texttt{0.1101}$ , $[y]_补=\texttt{0.1011}$ , 求 $[x\cdot y]_{补}$ 

解:

- $[-x]_补 = \texttt{1.0011}$ 

$$
\begin{array}{|c|c|}
\hline
部分积 & 乘数 & 附加位(y_{n+1}) & y_{n}y_{n+1} & 说明 \\
\hline
\texttt{00.0000} & \texttt{|0101{\color{red}1}} & \texttt{\color{green}0} & \texttt{{\color{red}1}{\color{green}0}} & y_{n+1}=0, 初值部分积为\texttt{0} \\
\hline
\begin{array}{r}
\texttt{00.0000} \\
\texttt{+11.0011} \\
\texttt{=11.0011} \\
\texttt{>>1} \\
\texttt{11.1001}
\end{array} &
\texttt{1|010{\color{red}1}} & \texttt{{\color{green}1}} & \texttt{{\color{red}1}{\color{green}1}} & 
\begin{array}{}
根据上步标识\texttt{10},\\
部分积加[-x]_{补}后右移1位
\end{array} \\
\hline
\begin{array}{r}
\texttt{{ }11.1001} \\
\texttt{>>1} \\
\texttt{11.1100}
\end{array} &
\texttt{11|01{\color{red}0}} & \texttt{{\color{green}1}} & \texttt{{\color{red}0}{\color{green}1}} & 
\begin{array}{}
根据上步标识\texttt{11},\\
部分积右移1位
\end{array} \\
\hline
\begin{array}{r}
\texttt{11.1100} \\
\texttt{+00.1101} \\
\texttt{=00.1001} \\
\texttt{>>1} \\
\texttt{00.0100}
\end{array} &
\texttt{111|0{\color{red}1}} & \texttt{{\color{green}0}} & \texttt{{\color{red}1}{\color{green}0}} & 
\begin{array}{}
根据上步标识\texttt{01},\\
部分积加[x]_{补}后右移1位
\end{array} \\
\hline
\begin{array}{r}
\texttt{00.0100} \\
\texttt{+11.0011} \\
\texttt{=11.0111} \\
\texttt{>>1} \\
\texttt{11.1011}
\end{array} &
\texttt{1111|{\color{red}0}} & \texttt{{\color{green}1}} & \texttt{{\color{red}0}{\color{green}1}} & 
\begin{array}{}
根据上步标识\texttt{10},\\
部分积加[-x]_{补}后右移1位
\end{array} \\
\hline
\begin{array}{r}
\texttt{11.1011} \\
\texttt{+00.1101} \\
\texttt{=00.1000} \\
\end{array} &
\texttt{1111|{\color{red}}} & \texttt{{\color{green}}} & \texttt{{\color{red}}{\color{green}}} & 
\begin{array}{}
根据上步标识\texttt{01},\\
部分积加[x]_{补}, \\
最后一步不移位,得到结果
\end{array} \\
\hline
\end{array}
$$

最终结果为 $\texttt{0.10001111}$ .

Booth算法取双符号位, 因为符号位也参与运算, 并且过程中会进行右移 $1$ 为操作, 因此符号位取 $1+1=2$ 位.


例:

> 设 $[x]_补=\texttt{1.0101}$ , $[y]_补=\texttt{1.0011}$ , 求 $[x\cdot y]_{补}$ 

解:

- $[-x]_{补} = 0.1011$

$$
\begin{array}{|c|c|}
\hline
部分积 & 乘数 & 附加位(y_{n+1}) & y_{n}y_{n+1} \\
\hline
\texttt{00.0000} & \texttt{|10011} & \texttt{0} & \texttt{10} \\
\hline
\begin{array}{r}
\texttt{00.0000} \\
\texttt{+00.1011} \\
\texttt{=00.1011} \\
\texttt{>>1} \\
\texttt{00.0101}
\end{array} &
\texttt{1|1001} & \texttt{1} & \texttt{11} \\
\hline
\begin{array}{r}
\texttt{{ }00.0101} \\
\texttt{>>1} \\
\texttt{00.0010}
\end{array} &
\texttt{11|100} & \texttt{1} & \texttt{01} \\
\hline
\begin{array}{r}
\texttt{00.0010} \\
\texttt{+11.0101} \\
\texttt{=11.0111} \\
\texttt{>>1} \\
\texttt{11.1011}
\end{array} &
\texttt{111|10} & \texttt{0} & \texttt{00} \\
\hline
\begin{array}{r}
\texttt{11.1011} \\
\texttt{>>1} \\
\texttt{11.1101}
\end{array} &
\texttt{1111|1} & \texttt{0} & \texttt{10} \\
\hline
\begin{array}{r}
\texttt{11.1101} \\
\texttt{+00.1011} \\
\texttt{=00.1000} \\
\end{array} &
\texttt{1111|} & \texttt{} & \texttt{} \\
\hline
\end{array}
$$

结果为 $\texttt{0.10001111}$ .


<font color=red><b>补码两位乘</b></font>

补码两位乘 (使用 Booth 算法) , 是根据补码一位乘的规则, 将:
- $y_{n}y_{n+1}$ 的状态对应执行的操作
- $y_{n-1}y_{n}$ 的状态对应执行的操作
合并成一步操作得到的.

例如, 若 $y_{n-1}y_{n}y_{n+1} = \texttt{011}$ :
- 有 $y_{n}y_{n+1} = \texttt{11}$ , 对应的操作为仅右移 $1$ 位, 即 $2^{-1}[z_i]_补$ . 
- 有 $y_{n-1}y_{n} = \texttt{01}$ , 对应的操作为 $+[x]_补$ 后右移 $1$ 位, 即 $2^{-1}\{2^{-1}[z_i]_补+[x]_补\}$ .

将操作写作算式, 相当于复合函数展开:

$$
2^{-2}\{[z_i]+2[x]_补\}
$$

将原本串行的执行操作, 变成了一次整合的操作完成. 牺牲了单次操作的复杂度, 但是换来了循环次数减半.

其运算规则为:

$$
\begin{array}{|c|l|}
\hline
\begin{array}{c}判断位\\[-4pt]y_{n-1}y_{n}y_{n+1}\end{array} & \qquad\qquad\ \ 操作内容 \\
\hline
\texttt{000} & [z_{i+1}]_补 = 2^{-2}[z_i]_补 \\
\hline
\texttt{001} & [z_{i+1}]_补 = 2^{-2}\{[z_i]_补+[x]_补\} \\
\hline
\texttt{010} & [z_{i+1}]_补 = 2^{-2}\{[z_i]_补+[x]_补\} \\
\hline
\texttt{011} & [z_{i+1}]_补 = 2^{-2}\{[z_i]_补+2[x]_补\} \\
\hline
\texttt{100} & [z_{i+1}]_补 = 2^{-2}\{[z_i]_补+2[-x]_补\} \\
\hline
\texttt{101} & [z_{i+1}]_补 = 2^{-2}\{[z_i]_补+[-x]_补\} \\
\hline
\texttt{110} & [z_{i+1}]_补 = 2^{-2}\{[z_i]_补+[-x]_补\} \\
\hline
\texttt{111} & [z_{i+1}]_补 = 2^{-2}[z_i]_补 \\
\hline
\end{array}
$$

例:

> 设 $[x]_补=\texttt{0.0101}$ , $[y]_补=\texttt{1.0101}$ , 求 $[x\cdot y]_{补}$ 

解:

$$
\begin{array}{|c|c|}
\hline
部分积 & 乘数 & 标记位 & 说明 \\
\hline
\texttt{000.0000} & \texttt{|11.01010} & \texttt{010} & 初始状态 \\
\hline
\begin{array}{r}
\texttt{000.0000} \\
\texttt{+000.0101} \\
\texttt{=000.0101} \\
\texttt{>>2} \\
\texttt{000.0001}
\end{array} & 
\texttt{01|11.010} & \texttt{010} & 根据\texttt{010}操作 \\
\hline
\begin{array}{r}
\texttt{000.0001} \\
\texttt{+000.0101} \\
\texttt{=000.0110} \\
\texttt{>>2} \\
\texttt{000.0001}
\end{array} & 
\texttt{1001|11.0} & \texttt{110} & 根据\texttt{010}操作 \\
\hline
\begin{array}{r}
\texttt{000.0001} \\
\texttt{+111.1011} \\
\texttt{=111.1100}
\end{array} & 
\texttt{1001|} & & 最后一步不移位 \\
\hline
\end{array}
$$

最终结果为 $\texttt{1.11001001}$ .


## 除法运算

### 真值除法

首先分析笔算除法的过程:

例:

> $x = \texttt{-0.1011}$ , $y=\texttt{0.1101}$ , 求 $x/y$ .

解:

商的符号通过负正得负确定, 数值部分的运算为:

$$
\begin{array}{r}
{ }\\{ \texttt{0.1101})}\\{ }\\{ }\\{ }\\{ }\\{ }\\{ }
\end{array}
\begin{array}{l}
\texttt{0.1101}\\
\hline
\texttt{0.10110}\\
\texttt{0.01101}\\
\hline
\texttt{0.010010}\\
\texttt{0.001101}\\
\hline
\texttt{0.00010100}\\
\texttt{0.00001101}\\
\hline
\texttt{0.00000111}
\end{array}
$$
即, 商为 $\texttt{-0.1101}$ , 余数为 $\texttt{0.00000111}$ .
商计算到 $\texttt{-0.1101}$ 为止, 是因为商只能容纳 $4$ 位数值位. 


### 原码除法

原码除法的符号位是单独通过异或算符处理的.
商值通过两数绝对值相除获得.

小数定点除法对被除数和除数有如下要求:

$$
0<|被除数|\leq|除数|
$$

即预期结果必须为纯小数, 不能含有大于 $0$ 的整数部分. 
被除数不为 $0$ , 以避免计算浪费时间.
除数不为 $0$ , 以避免结果无穷大, 无法表示.

原码除法按对余数的不同处理方式可分为**恢复余数法**和**加减交替法**.

<font color=red><b>恢复余数法</b></font>

恢复余数法的特点是: 当余数为负时, 需加上除数, 将其恢复成原本的余数.

计算商值的过程, 是通过比较被除数和除数的绝对值大小实现的, 即 $|x|-|y|$ , 补码计算为 $[|x|]_补 + [-|y|]_补$ .

本质上, 恢复余数的过程是一次 "机器心算" , 因为机器不知道应该上商 $\texttt{0}$ 还是上商 $\texttt{1}$ , 因此只能通过尝试的方式, 针对正在确定商值的某一位计算过程:

- 先上商 $\texttt{1}$ , 然后计算 $上一步余数 - 当前位对应偏移\times除数$ , 判断该值是否为正:
	- 若为正, 说明上商 $\texttt{1}$ 是正确的, 计算新的余数, 供下位计算使用
	- 若为负, 说明余数不够上商 $\texttt{1}$ 对应的除数, 应当上商 $\texttt{0}$ , 因此恢复余数, 供下位计算使用.
- 计算下一位.

以下案例说明**恢复余数法**的求解过程:

例:

> $x = \texttt{-0.1011}$ , $y = \texttt{-0.1101}$ , 求 $\left[\dfrac{x}{y}\right]_原$ .

解:

- $[x]_原 = \texttt{1.1011}$ 
- $[|x|]_原 = \texttt{0.1011}$ 
- $[y]_原 = \texttt{1.1101}$ 
- $[|y|]_原 = \texttt{0.1101}$
- $[-|y|]_补 = \texttt{1.0011}$

$$
\begin{array}{|c|c|}
\hline
\begin{array}{c}被除数\\(余数)\end{array} & 
\begin{array}{c}商\\[-2pt]\texttt{x.xxxx}\end{array} & 
说明 \\
\hline
\begin{array}{r}
\texttt{ 0.1011}\\
\end{array}
& \texttt{ } & 初始状态 \\
\hline
\begin{array}{r}
\texttt{ 0.1011} \\
\texttt{+1.0011} \\
\texttt{=1.1110} \\
\texttt{ 1.1110} \\
\texttt{+0.1101} \\
\texttt{=0.1011}
\end{array}
& \texttt{0.{ }{ }{ }{ }} & 
\begin{array}{}
比较数位2^{0}\\
上商\texttt{0}\\
{\color{red}恢复余数}
\end{array} \\
\hline
\begin{array}{r}
\texttt{ 0.1011} \\
\texttt{<<1} \\
\texttt{1.0110} \\
\texttt{+1.0011} \\
\texttt{=0.1001}
\end{array}
& \texttt{0.{1}{ }{ }{ }} & 
\begin{array}{}
比较数位2^{-1}\\
上商\texttt{1}
\end{array} \\
\hline
\begin{array}{r}
\texttt{ 0.1001} \\
\texttt{<<1} \\
\texttt{1.0010} \\
\texttt{+1.0011} \\
\texttt{=0.0101}
\end{array}
& \texttt{0.{1}{1}{ }{ }} & 
\begin{array}{}
比较数位2^{-2}\\
上商\texttt{1}
\end{array} \\
\hline
\begin{array}{r}
\texttt{ 0.0101} \\
\texttt{<<1} \\
\texttt{ 0.1010} \\
\texttt{+1.0011} \\
\texttt{=1.1101} \\
\texttt{ 1.1101} \\
\texttt{+0.1101} \\
\texttt{=0.1010} \\
\end{array}
& \texttt{0.{1}{1}{0}{ }} & 
\begin{array}{}
比较数位2^{-3} \\
上商\texttt{0} \\
{\color{red}恢复余数}
\end{array} \\
\hline
\begin{array}{r}
\texttt{ 0.1010} \\
\texttt{    <<1} \\
\texttt{ 1.0100} \\
\texttt{+1.0011} \\
\texttt{=0.0111}
\end{array}
& \texttt{0.{1}{1}{0}{1}} & 
\begin{array}{}
比较数位2^{-4} \\
上商\texttt{1}
\end{array} \\
\hline
\end{array}
$$

商数值部分为 $\texttt{0.1101}$ , 对应的余数为 $\texttt{0.0111}\times 2^{-4} = \texttt{0.00000111}$ , 余数不关心.

叠加符号位, 最终的商为 $\texttt{0.1101}$ .

在上例中, 一共进行了 $4$ 次左移操作, 上商 $5$ 次, 每余数为负时, 即需要恢复余数.

对于整数位上的上商, 其作用为判断商是否为纯小数.

恢复余数法操作较多, 使用加减交替法可克服缺点.


<font color=red><b>加减交替法</b></font>

分析恢复余数法:
- 当余数 $R_i>0$ 时, 上商 $\texttt{1}$ , 再对 $R_i$ 左移一位后减除数, 即 $2R_i - |y|$ .
- 当余数 $R_i>0$ 时, 上商 $\texttt{0}$ , 先做 $R_i+|y|$ 恢复余数, 再做左移一位后减除数, 即 $2(R_i+|y|)-|y| = 2R_i+|y|$ .

归纳如下:
- 当余数 $R_i>0$ 时, 上商 $\texttt{1}$ , 后续操作为 $2R_i - |y|$ .
- 当余数 $R_i<0$ 时, 上商 $\texttt{0}$ , 后续操作为 $2R_i + |y|$ .

可见, 无需判断是否需要恢复余数, 而是使用固定的加减法代替, 优化了流程结构.

例:

> $x = \texttt{-0.1011}$ , $y = \texttt{0.1101}$ , 求 $\left[\dfrac{x}{y}\right]_原$ .

解:

- $[x]_原 = \texttt{1.1011}$ 
- $|x| = \texttt{0.1011}$ 
- $[y]_原 = \texttt{0.1101}$ 
- $|y| = \texttt{0.1101}$ 
- $[-|y|]_补 = 1.0011$

$$
\begin{array}{|c|c|}
\hline
\begin{array}{c}被除数\\(余数)\end{array} & 
\begin{array}{c}商\\[-2pt]\texttt{x.xxxx}\end{array} & 
说明 \\
\hline
\begin{array}{r}
\texttt{ 0.1011} \\
\texttt{+1.0011} \\
\texttt{=1.1110}
\end{array} & & 初始余数 \\
\hline
\begin{array}{r}
\texttt{ 1.1110} \\
\texttt{    <<1} \\
\texttt{ 1.1100} \\
\texttt{+0.1101} \\
\texttt{=0.1001} \\
\end{array} & \texttt{0.{ }{ }{ }{ }} &
\begin{array}{c}
比较数位2^{0}\\
上商\texttt{0}\\
\end{array} \\
\hline
\begin{array}{r}
\texttt{ 0.1001} \\
\texttt{    <<1} \\
\texttt{ 1.0010} \\
\texttt{+1.0011} \\
\texttt{=0.0101} \\
\end{array} & \texttt{0.{1}{ }{ }{ }} &
\begin{array}{c}
比较数位2^{1}\\
上商\texttt{1}\\
\end{array} \\
\hline
\begin{array}{r}
\texttt{ 0.0101} \\
\texttt{    <<1} \\
\texttt{ 0.1010} \\
\texttt{+1.0011} \\
\texttt{=1.1101} \\
\end{array} & \texttt{0.{1}{1}{ }{ }} &
\begin{array}{c}
比较数位2^{2}\\
上商\texttt{1}\\
\end{array} \\
\hline
\begin{array}{r}
\texttt{ 1.1101} \\
\texttt{    <<1} \\
\texttt{ 1.1010} \\
\texttt{+0.1101} \\
\texttt{=0.0111} \\
\end{array} & \texttt{0.{1}{1}{0}{ }} &
\begin{array}{c}
比较数位2^{3}\\
上商\texttt{0}\\
\end{array} \\
\hline
\texttt{0.0111} & \texttt{0.1101} & 
\begin{array}{c}
比较数位2^{4}\\
上商\texttt{1}\\
\end{array} \\
\hline
\end{array}
$$

符号位为 $x_0\oplus y_0 = 1\oplus 0 = 1$ , 因此, 商为 $\texttt{1.1101}$ 


整数除法类似小数除法, 但对被除数和除数的要求变为:

$$
0<|除数|\leq|被除数|
$$

目的是得到整数值的商, 而不是纯小数.


### 补码除法

补码除法也分为恢复余数法和加减交替法. 实际加减交替法使用更多.

补码除法中, 符号位也参与数值计算, 不如原码除法直观, 算法需要解决三个重点问题:
1. 如何计算商值
2. 如何计算商符
3. 如何获取新余数


**计算商值**

首先判断被除数 (余数) 和除数的大小.
补码除法操作数均为补码, 符号也是任意的, 比较规则如下:

$$
\begin{array}{|c|c|}
\hline
比较[x]_{补}与[y]_{补}符号 & 求余数 & 比较[R_i]_{补}与[y]_{补}符号 \\
\hline
同号 & [x]_{补} - [y]_{补} & 同号, 表示够减 \\
\hline
异号 & [x]_{补} + [y]_{补} & 异号, 表示够减 \\
\hline
\end{array}
$$

确定商值时, 正商和负商的上商规则是不同的, 负商的情况下, 除末位商外, 其余任何一位商都与真值相反.

结合比较规则和上商规则, 总结为下表:

$$
\begin{array}{|c|c|}
\hline
[x]_{补}与[y]_补 & 商 & [R]_{补}与[y]_{补} & 商值 \\
\hline
同号 & 正 & 
\begin{array}{c}
同号, 表示够减 \\
\hline
异号, 表示不够减
\end{array} & 
\begin{array}{c}
\texttt{{ }{ }1{ }{ }} \\
\hline
\texttt{{ }{ }0{ }{ }}
\end{array} \\
\hline
异号 & 负 & 
\begin{array}{c}
异号, 表示够减 \\
\hline
同号, 表示不够减
\end{array} & 
\begin{array}{c}
\texttt{{ }{ }0{ }{ }} \\
\hline
\texttt{{ }{ }1{ }{ }}
\end{array} \\
\hline
\end{array}
$$

进一步简化得到:

$$
\begin{array}{|c|c|}
\hline
[R]_{补}与[y]_{补} & 商值 \\
\hline
同号 & \texttt{1} \\
\hline
异号 & \texttt{0} \\
\hline
\end{array}
$$

商符是在求商的过程中自动形成的, 商符还可以用于判断溢出:
- 当 $[x]_{补}$ 和 $[y]_{补}$ 同号时, 若 $[R_0]_{补}$ 和 $[y]_补$ 同号, 上商 $\texttt{1}$ , 即为溢出.
- 当 $[x]_{补}$ 和 $[y]_{补}$ 异号时, 若 $[R_0]_{补}$ 和 $[y]_补$ 异号, 上商 $\texttt{0}$ , 即为溢出.

新余数的获得方法与原码加减交替法类似, 规则如下:

$$
\begin{array}{|c|c|}
\hline
[R_i]_{补}与[y]_{补} & 商 & 新余数 [R_{i+1}]_{补} \\
\hline
同号 & \texttt{1} & [R_{i+1}]_{补} = 2[R_i]_{补} + [-y]_{补} \\
\hline
异号 & \texttt{0} & [R_{i+1}]_{补} = 2[R_i]_{补} + [y]_{补} \\
\hline
\end{array}
$$

若对于商的精度没有要求, 可采用 <font color=red><b>末位恒置 1</b></font> 法, 将最末尾置 $1$ , 最大误差为 $2^{-n}$ .

例:

> $x = \texttt{0.1001}$ , $y = \texttt{0.1101}$ , 求 $\left[\dfrac{x}{y}\right]_{补}$ .

解:

- $[x]_补 = \texttt{0.1001}$ 
- $[y]_补 = \texttt{0.1101}$ 
- $[-y]_补 = \texttt{1.0011}$ 

$$
\begin{array}{|c|c|}
\hline
\begin{array}{}
被除数\\(余数)
\end{array} & 商 & 说明 \\
\hline
\begin{array}{r}
\texttt{ 0.1001} \\
\texttt{+1.0011} \\
\texttt{=1.1100} \\
\end{array} & & 准备初始余数\\
\hline
\begin{array}{r}
\texttt{ 1.1100} \\
\texttt{    <<1} \\
\texttt{=1.1000} \\
\texttt{+0.1101} \\
\texttt{=0.0101}
\end{array} & \texttt{0.{ }{ }{ }{ }} & 
\begin{array}{c} 
判断数位2^0 \\
准备新余数
\end{array} \\
\hline
\begin{array}{r}
\texttt{ 0.0101} \\
\texttt{    <<1} \\
\texttt{=0.1010} \\
\texttt{+1.0011} \\
\texttt{=1.1101}
\end{array} & \texttt{0.{1}{ }{ }{ }} & 
\begin{array}{c} 
判断数位2^{-1} \\
准备新余数
\end{array} \\
\hline
\begin{array}{r}
\texttt{ 1.1101} \\
\texttt{    <<1} \\
\texttt{=1.1010} \\
\texttt{+0.1101} \\
\texttt{=0.0111}
\end{array} & \texttt{0.{1}{0}{ }{ }} & 
\begin{array}{c} 
判断数位2^{-2} \\
准备新余数
\end{array} \\
\hline
\begin{array}{r}
\texttt{ 0.0111} \\
\end{array} & \texttt{0.{1}{0}{1}{1}} & 
\begin{array}{c} 
判断数位2^{-3} \\
末位恒置 \texttt{1}
\end{array} \\
\hline
\end{array}
$$

结果为 $\texttt{0.1011}$ .


例:

> $x = \texttt{-0.1001}$ , $y = \texttt{+0.1101}$ , 求 $\left[\dfrac{x}{y}\right]_{补}$ .

解:

- $[x]_{补} = \texttt{1.0111}$ 
- $[y]_{补} = \texttt{0.1101}$ 
- $[-y]_{补} = \texttt{1.0011}$

$$
\begin{array}{|c|c|}
\hline
\begin{array}{}
被除数\\(余数)
\end{array} & 商 & 说明 \\
\hline
\begin{array}{r}
\texttt{ 1.0111} \\
\texttt{+0.1101} \\
\texttt{=0.0100} \\
\end{array} & & 准备初始余数\\
\hline
\begin{array}{r}
\texttt{ 0.0100} \\
\texttt{    <<1} \\
\texttt{=0.1000} \\
\texttt{+1.0011} \\
\texttt{=1.1011}
\end{array} & \texttt{1.{ }{ }{ }{ }} & 
\begin{array}{c} 
判断数位2^0 \\
准备新余数
\end{array} \\
\hline
\begin{array}{r}
\texttt{ 1.1011} \\
\texttt{    <<1} \\
\texttt{=1.0110} \\
\texttt{+0.1101} \\
\texttt{=0.0011}
\end{array} & \texttt{1.{0}{ }{ }{ }} & 
\begin{array}{c} 
判断数位2^{-1} \\
准备新余数
\end{array} \\
\hline
\begin{array}{r}
\texttt{ 0.0011} \\
\texttt{    <<1} \\
\texttt{=0.0110} \\
\texttt{+1.0011} \\
\texttt{=1.1001}
\end{array} & \texttt{1.{0}{1}{}{ }} & 
\begin{array}{c} 
判断数位2^{-2} \\
准备新余数
\end{array} \\
\hline
\begin{array}{r}
\texttt{ 1.1001} \\
\end{array} & \texttt{1.{0}{1}{0}{1}} & 
\begin{array}{c} 
判断数位2^{-3} \\
末位恒置 \texttt{1}
\end{array} \\
\hline
\end{array}
$$

$n$ 位小数补码除法共上商 $n+1$ 次, 其中末位恒置 $\texttt{1}$ , 整数位商用于判断是否溢出. 供进行 $n$ 次移位, 并用移位次数判断除法结束.


# 6.4 浮点四则运算

## 浮点加减运算

设两个浮点数分别为:

$$
\begin{align}
x&=S_x \cdot r^{jx} \\
y&=S_y \cdot r^{jy}
\end{align}
$$

由于浮点数的小数点均固定在第一位数值位前, 因此位数的加减运算与定点数相同, 但由于其阶码的大小决定了实际小数点的位置, 因此在尾数计算前还要处理阶数的部分.

浮点数加减运算的过程如下:
1. **对阶**, 使两数的小数点位置对齐.
2. **尾数求和**, 将对阶后的两尾数按定点加减计算.
3. **规格化**, 为提升精度, 将计算后的尾数规格化.
4. **舍入**, 为提升精度, 在对阶和向右规格化过程中, 使用舍入法提升尾数精度.
5. **溢出判断**.

<font color=red><b>对阶</b></font>

对阶的目的是使两个操作数的小数点位置对齐, 使阶码相等.
为此, 需要先求出阶数差, 再按照**小阶向大阶看齐**的原则, 使阶数较小的尾数向右移位, 每右移 $1$ 位, 阶码加 $1$ , 直到两数阶码相同.
右移的次数等于阶差. 右移过程中会发生位丢弃, 损失精度.

例如, 将 $x=0.1101\times 2^{01}$ 和 $y=(-0.1010)\times 2^{11}$ 对阶.

$$
\begin{align}
[x]_{补} &= 00,01;00.1101 \\
[y]_{补} &= 00,11;11.0110
\end{align}
$$

阶差为:

$$
\begin{align}
[\Delta_{j}]_{补} &= [j_{x}]_{补} - [j_{y}]_{补} \\
&= 00,01+11,01 \\
&=11,10
\end{align}
$$

即阶差为: $-2$ , 表示 $x$ 比 $y$ 的阶码小, 按小阶向大阶看齐的原则, 将 $x$ 的尾数右移两位, 其阶码 $+2$ , 得到:

$$
[x]_{补} = 00,11;00.0011
$$


<font color=red><b>尾数求和</b></font>

将对阶后的两个尾数按定点运算规则进行计算.


<font color=red><b>规格化</b></font>

当基值为 $2$ 时, 尾数 $S$ 的规格化后范围为:

$$
\frac{1}{2} \leq S < 1
$$

若采取双符号位补码, 则:

$$
\begin{align}
S>0时: \quad [S]_补 &=00.1\cdots \\
S<0时: \quad [S]_补 &=11.0\cdots
\end{align}
$$

即, 当符号位与尾数最高数值位不同时, 为规格化形式.

左规:  
当尾数出现 $\texttt{00.0}\cdots$ 或 $\texttt{11.1}\cdots$ 时, 需要左规.

右规:  
当尾数出现 $\texttt{01.}\cdots$ 或 $\texttt{10.}\cdots$ 时, 表示尾数溢出, 在定点运算中是不允许的, 但在浮点运算中可以通过右规处理.

例:

> $x=0.1101\times2^{10}$ , $y=0.1011\times2^{01}$ , 求 $x+y$ .

解:

$$
\begin{align}
[x]_{补} = \texttt{00,10;00.1101} \\
[y]_{补} = \texttt{00,01;00.1011} \\
\end{align}
$$

- 对阶

$$
\begin{align}
[\Delta_j]_{补} &= [j_x]_补 - [j_y]_补 \\
&=\texttt{00,10} + \texttt{11,11} \\
&=\texttt{00,01}
\end{align}
$$

表明 $y$ 的阶码较小, 将 $y$ 的位数右移 $1$ 位, 阶码加 $1$ , 得到:

$$
[y]_{补}' = \texttt{00,10;00.0101}
$$

- 求和

$$
\begin{align}
\texttt{00.1101}+\texttt{00.0101} = \texttt{01.0010}\\
[x+y]_{补} = \texttt{00,10;01.0010}\\
\end{align}
$$

- 右规

运算结果符号位不等, 表示尾数之和绝对值大于 $1$ , 因此需要将尾数右移 $1$ 位, 阶码加 $1$ , 得到:

$$
[x+y]_{补} = \texttt{00,11;00.1001}
$$

即 $x+y=0.1001\times 2^{11}$ .


<font color=red><b>舍入</b></font>

在对阶和右规过程中, 可能丢弃尾数低位, 引起误差, 影响精度, 使用舍入法提高尾数竞速, 有以下两种方法:
- " $0$ 舍 $1$ 入"法: 类似四舍五入, 即在尾数右移时, 被丢弃的最高位值为 $0$ 则直接舍去, 被丢弃的最高位为 $1$ 则尾数末位加 $1$ . 该方法可能造成尾数再次溢出, 需要再次右规.
- "恒置 $1$ "法: 位数右移时, 无论丢弃的最高位数值是 $0$ 或 $1$ , 都使右移后的尾数末位恒置 $1$ . 该方法同样可能使尾数变大或变小.

例: 

> $x = 2^{-101}\times (-0.101000)$ , $y=2^{-100}\times(+0.111011)$ , 阶符取 $2$ 位, 阶码数值部分取 $3$ 位, 数符取 $2$ 位, 尾数数值部分取 $6$ 位, 求 $x-y$ .

解:

$$
\begin{align}
[x]_{补} &= \texttt{11,011;11.011000}\\
[y]_{补} &= \texttt{11,100;00.111011}
\end{align}
$$

- 对阶

$$
[x]_{补}' = \texttt{11,100;11.101100}
$$

- 求和

$$
\begin{align}
\texttt{11.101100}+\texttt{11.000101} = \texttt{10,110001}\\
[x-y]_{补} = \texttt{11,100;10,110001}\\
\end{align}
$$

- 右规 & 舍入

$$
[x-y]_{补} = \texttt{11,101;11.011001}
$$


<font color=red><b>溢出判断</b></font>

在浮点计算中, 出现 $\texttt{01.}\cdots$ 或 $\texttt{10.}\cdots$ 时并不表示溢出, 需要先将数进行右规后, 根据阶码判断浮点结果是否溢出.

浮点的溢出由阶码的符号决定, 即:
- 阶码 $[j]_{补} = \texttt{01,}\cdots$ 为上溢.
- 阶码 $[j]_{补} = \texttt{10,}\cdots$ 为下溢.

当上溢时, 需要做溢出处理, 当下溢时, 按机器零处理.


## 浮点乘除运算

两浮点数相乘, 乘积的阶码等于两数阶码和, 乘积的尾数等于两数尾数积.
两浮点数相除, 商的阶码等于两数阶码差, 商的尾数等于两数尾数商.

运算过程中需要考虑规格化与舍入问题.

<font color=red><b>阶码运算</b></font>

若阶码使用**补码**运算:

则乘积的阶码为 $[j_{x}]_{补} + [j_{y}]_{补}$ , 商的阶码为 $[j_{x}]_{补} - [j_{y}]_{补}$ .
两个同号的阶码相加或异号的阶码相减可能产生溢出, 因此需要溢出判断.

若阶码使用**移码**运算:

根据移码的定义, $[j_x]_{移} = 2^{n}+j_{x}$ , $[j_{y}]_{移} = 2^n+j_{y}$ , 即将补码符号位翻转. 则有:

$$
\begin{align}
[j_{x}]_{移} + [j_{y}]_{移} &= 2^n + j_x + 2^n + j_y \\
&= 2^n + [2^n + (j_x+j_y)] \\
&= 2^n + [j_x+j_y]_{移}
\end{align}
$$

因此移码等于相乘两数移码和减 $2^n$ . 可以通过如下公式计算积商的补码:

$$
\begin{align}
[j_x]_{移} + [j_y]_{补} = [j_x+j_y]_{移} \\
[j_x]_{移} + [-j_y]_{补} = [j_x-j_y]_{移} \\
\end{align}
$$

移码的溢出检测需要在符号位前增加一个标记为, 规定该为恒为 $0$ , 若该标记为在运算后变为 $1$ 则为溢出.


<font color=red><b>尾数运算</b></font>

**乘法尾数计算**

首先判断相乘两数是否存在 $0$ , 若存在则结果为 $0$ .

尾数相乘的结果可能需要左规, 左规时判断阶码是否溢出: 
- 若下溢, 则按机器 $0$ 处理
- 若上溢, 则做出溢出处理

此外, 尾数相乘会获得双倍字长的结果, 若限定仅取 $1$ 倍字长, 则乘积的若干位会被丢弃, 丢弃方式通常有两种:
- 截断: 无条件丢弃正常尾数最低位后的全部数值.
- 舍入: 按浮点加减运算的两种舍入规则进行舍入.

例:

> $x = 2^{-101}\times\texttt{0.0110011}$ , $y = 2^{011}\times(-0.1110010)$ , 求 $x\times y$ .

解:

$$
\begin{align}
[x]_{补} = \texttt{11,011;00.0110011} \\
[y]_{补} = \texttt{00,011;11.0001110}
\end{align}
$$

阶码计算:

$$
\begin{align}
[j_x+j_y]_{移} &= [j_x]_{移}+[j_y]_{补} \\
&=\texttt{00,011}+\texttt{00,011} \\
&=\texttt{00,110}(真值:-2)
\end{align}
$$

尾数相乘:

使用 Booth 算法:

- $[-S_x]_{补} = \texttt{11.1001101}$ 

$$
\begin{array}{|c|c|}
\hline
部分积 & 乘数 & 附加位(y_{n+1}) & y_{n}y_{n+1} \\
\hline
\texttt{ 00.0000000} & \texttt{|1.0001110} & \texttt{0} & \texttt{00} \\
\hline
\begin{array}{r}
\texttt{ 00.0000000} \\
\texttt{        >>1} \\
\texttt{ 00.0000000} \\
\end{array} & \texttt{0|1.000111} & \texttt{0} & \texttt{10} \\
\hline
\begin{array}{r}
\texttt{ 00.0000000} \\
\texttt{+11.1001101} \\
\texttt{=11.1001101} \\
\texttt{        >>1} \\
\texttt{ 11.1100110} \\
\end{array} & \texttt{10|1.00011} & \texttt{1} & \texttt{11} \\
\hline
\begin{array}{r}
\texttt{ 11.1100110} \\
\texttt{        >>1} \\
\texttt{ 11.1110011} \\
\end{array} & \texttt{010|1.0001} & \texttt{1} & \texttt{11} \\
\hline
\begin{array}{r}
\texttt{ 11.1110011} \\
\texttt{        >>1} \\
\texttt{ 11.1111001} \\
\end{array} & \texttt{1010|1.000} & \texttt{1} & \texttt{01} \\
\hline
\begin{array}{r}
\texttt{ 11.1110011} \\
\texttt{+00.0110011} \\
\texttt{=00.0101100} \\
\texttt{        >>1} \\
\texttt{ 00.0010110} \\
\end{array} & \texttt{01010|1.00} & \texttt{0} & \texttt{00} \\
\hline
\begin{array}{r}
\texttt{ 00.0010110} \\
\texttt{        >>1} \\
\texttt{ 00.0001011} \\
\end{array} & \texttt{001010|1.0} & \texttt{0} & \texttt{00} \\
\hline
\begin{array}{r}
\texttt{ 00.0001011} \\
\texttt{        >>1} \\
\texttt{ 00.0000101} \\
\end{array} & \texttt{1001010|1.} & \texttt{0} & \texttt{10} \\
\hline
\begin{array}{r}
\texttt{ 00.0000101} \\
\texttt{+11.1001101} \\
\texttt{=11.1010010} \\
\end{array} & \texttt{1001010|{ }{ }} \\
\hline
\end{array}
$$

尾数相乘结果为 $\texttt{11.10100101001010}$ , 需要左规:

$$
\begin{align}
[x\cdot y]_{补} &= \texttt{11,110;11.10100101001010} \\
&= \texttt{11,101;11.01001010010100} \\
\end{align}
$$

取 $1$ 倍字长, 最终舍入后结果为:

$$
[x\cdot y]_{补} = \texttt{11,101;11.0100101}
$$


**除法尾数计算**

- 首先判断除数是否为 $0$ , 若为 $0$ 则特殊处理, 若不为 $0$ , 再判断被除数是否为 $0$ , 若为 $0$ 则商为 $0$ , 若均不为 $0$ , 则进行尾数运算.

- 对已规格化的尾数, 为防止除法结果溢出, 可先比较被除数和除数绝对值, 若被除数绝对值大于除数, 则将被除数右移 $1$ 位, 其阶码加 $1$ 再做尾数相除, 此时得到的结果必然是规格化定点小数.

例:

> $\left[2^{5}\times\left(+\dfrac{9}{16}\right)\right]\div\left[2^{3}\times\left(-\dfrac{13}{16}\right)\right]$ 

解:

- $x=\left[2^{5}\times\left(+\dfrac{9}{16}\right)\right] = 2^{101}\times(0.1001)$ 
- $y=\left[2^{3}\times\left(-\dfrac{13}{16}\right)\right] = 2^{011}\times(-0.1101)$ 

- $[x]_{补} = \texttt{00,101;00.1001}$ 
- $[y]_{补} = \texttt{00,011;11.0011}$ 
- $[-S_y]_{补} = \texttt{00.1101}$ 

阶码:

$$
[j_x]_{补} - [j_y]_{补} = \texttt{00,101}-\texttt{00,011} = \texttt{00,010}
$$

尾数:

$$
\begin{array}{|c|c|}
\hline
\begin{array}{}
被除数\\(余数)
\end{array} & 商 & 说明 \\
\hline
\begin{array}{r}
\texttt{ 00.1001} \\
\texttt{+11.0011} \\
\texttt{=11.1100} \\
\end{array} & & 准备初始余数\\
\hline
\begin{array}{r}
\texttt{ 11.1100} \\
\texttt{    <<1} \\
\texttt{=11.1000} \\
\texttt{+00.1101} \\
\texttt{=00.0101}
\end{array} & \texttt{1.{ }{ }{ }{ }} & 
\begin{array}{c} 
判断数位2^0 \\
准备新余数
\end{array} \\
\hline
\begin{array}{r}
\texttt{ 00.0101} \\
\texttt{    <<1} \\
\texttt{=00.1010} \\
\texttt{+11.1100} \\
\texttt{=11.1101}
\end{array} & \texttt{1.{0}{ }{ }{ }} & 
\begin{array}{c} 
判断数位2^{-1} \\
准备新余数
\end{array} \\
\hline
\begin{array}{r}
\texttt{ 11.1101} \\
\texttt{    <<1} \\
\texttt{=11.1010} \\
\texttt{+00.1101} \\
\texttt{=00.0111}
\end{array} & \texttt{1.{0}{1}{}{ }} & 
\begin{array}{c} 
判断数位2^{-2} \\
准备新余数
\end{array} \\
\hline
\begin{array}{r}
\texttt{ 00.0111} \\
\end{array} & \texttt{1.{0}{1}{0}{1}} & 
\begin{array}{c} 
判断数位2^{-3} \\
末位恒置 \texttt{1}
\end{array} \\
\hline
\end{array}
$$

由于尾数以规格化, 因此结果为:

$$
\left[
\frac{x}{y}
\right]_{补} = \texttt{00,010;11.0101}
$$


# 6.5 算术逻辑单元

ALU 单元是可以完成算数运算和逻辑运算的单元.

ALU 有两组输入, 一组控制, 一组输出. 控制信号决定 ALU 进行的具体逻辑运算和算术运算.

以 74181 为例, 有两种工作模式, 分别为正逻辑和负逻辑. 74181 本身不具备计算乘法或除法的能力.

74181 在进行非, 异或, 与, 或时都是按位处理的.

锁存器与寄存器:

锁存器 (Latch) 对电平敏感, 在控制信号有效期间, 数据会随时变化.  
例如典型的 D 型锁存器, 有一个使能信号 G 的电平控制. 输出 Q , 输入 D .  
当使能时, 锁存器是 "透明" 的. 透明状态下, 输出 Q 会跟随输入 D 变化.  
当失能时, 锁存器进入保持状态, 输出 Q 保持在失能前的值, 不再发生变化.  

寄存器 (Register) 对边沿敏感.  
典型的结构为 D 型触发器, 寄存器通常由多个 D 型触发器组成.  
有一个时钟信号的边沿控制, 数据只在时钟信号的边沿瞬间被捕获.  
数据捕获后, 输出 Q 保持不变, 直到下一个时钟捕获.  

锁存器可能长时间保持透明状态, 此时数据波动会传送到后面级, 造成计算错误.  
另外在同步设计时, 希望数据在一个时钟周期内仅改变一次, 且改变时刻受时钟控制. 锁存器在整个透明状态都允许数据流动, 使得时序分析复杂而不准确.  

锁存器有以下应用:
- 异步接口
- 总线驱动/缓冲
- 触发器的内部结构

74181 有正逻辑运算和负逻辑运算两种模式
- 正逻辑运算: 高电压为 1 , 低电压为 0 
- 负逻辑运算: 高电压为 0 , 低电压为 1

<font color=red><b>德摩根定律</b></font> (De Morgan's Law)

$$
\begin{align}
\overline{A\cdot B} = \overline{A} + \overline{B} \\
\overline{A+ B} = \overline{A} \cdot \overline{B} \\
\end{align}
$$

因此, 正逻辑下的 AND 门, 其对偶 (即负逻辑) 功能是 OR 门.  
通过引入负逻辑, 可以用一套固定的硬件, 通过切换逻辑定义, 实现更多的操作类型.

74181 的 $C_{-1}$ 或称为 $C_{n}$ 输入, 表示最低位的外来进位, 类似普通的初始进位, 向高位传递.

$C_{n}$ 有多种作用, 例如在加法运算中, 用于表示低位的进位; 在减法运算中, 用于补偿.

例如计算 $A-B$ 时, 按补码取相反数计算, 变为:

$$
A + (\overline{B} + 1) = A + \overline{B} + 1
$$

由于 $C_n$ 的输入是取反输入, 因此, 当 $C_n$ 输入 $0$ 时, 取反后变为 $+1$ , 即可计算减法.

74181 无法直接实现乘除运算, 乘除运算需要通过控制器控制 74181 进行运算. 控制器通过输出微指令直接控制 74181 进行时序对应的运算.

另外, 74181 仅有 4 位, 如果需要计算更多的位数, 需要将多个 74181 串接, 将进位相连.


## 快速进位链

随着操作数的位数增加, 进位速度对运算时间影响越来越大, 设计快速进位链提升进位速度.


<font color=red><b>半加器</b></font> (Half Adder, HA) 

半加器是最基础的加法单元, 执行两个**一位二进制数**的加法.  

其输入为:
- $A$ (第一个加数)
- $B$ (第二个加数)
其输出为:
- $S$ (Sum, 本位相加结果)
- $C$ (Carry, 向高位的进位)

半加器不能处理来自低位的进位, 只能用于多位加法的最低位, 或者单独执行两个一位二进制数的加法.


<font color=red><b>全加器</b></font> (Full Adder, FA) 

全加器是更完善的加法单元, 执行两个**一位二进制数**以及一个**低位进位**的加法.

其输入为:
- $A$ (第一个加数)
- $B$ (第二个加数)
- $C_{in}$ (Carry In, 低位进位)
其输出为:
- $S$ (Sum, 本位相加结果)
- $C_{out}$ (Carry Out, 高位进位)

一个全加器可以由两个半加器和一个或门构成.


<font color=red><b>并行加法器</b></font>

用 $n$ 位全加器实现两个 $n$ 位操作数同时相加的加法器称为并行加法器. 并行加法器中的全加器个数与操作数的位数相同.

有多种类型的并行加法器, 例如:
- 行波进位加法器 (Ripple-Carry Adder, RCA)
- 跳跃进位加法器 (Carry-Skip Adder, CSkA)
- 进位选择加法器 (Carry-Select Adder, CSA)
- 超前进位加法器 (Carry-Lookahead Adder, CLA)


观察输入输出的真值表, 以及对应的**最小项** (Minterm)

$$
\begin{array}{|c|c|}
\hline
A_i & B_i &C_{i-1} & S_i & C_{i} & 最小项 \\
\hline
\texttt{0} & \texttt{0} & \texttt{0} & \texttt{0} & \texttt{0} & \overline{A_i}\ \overline{B_i}\ \overline{C_{i-1}} \\
\hline
\texttt{0} & \texttt{0} & \texttt{1} & \texttt{1} & \texttt{0} & \overline{A_i}\ \overline{B_i}\ C_{i-1} \\
\hline
\texttt{0} & \texttt{1} & \texttt{0} & \texttt{1} & \texttt{0} & \overline{A_i}\ B_i\ \overline{C_{i-1}} \\
\hline
\texttt{0} & \texttt{1} & \texttt{1} & \texttt{0} & \texttt{1} & \overline{A_i}\ B_i\ C_{i-1} \\
\hline
\texttt{1} & \texttt{0} & \texttt{0} & \texttt{1} & \texttt{0} & A_i\ \overline{B_i}\ \overline{C_{i-1}} \\
\hline
\texttt{1} & \texttt{0} & \texttt{1} & \texttt{0} & \texttt{1} & A_i\ \overline{B_i}\ C_{i-1} \\
\hline
\texttt{1} & \texttt{1} & \texttt{0} & \texttt{0} & \texttt{1} & A_i\ B_i\ \overline{C_{i-1}} \\
\hline
\texttt{1} & \texttt{1} & \texttt{1} & \texttt{1} & \texttt{1} & A_i\ B_i\ C_{i-1} \\
\hline
\end{array}
$$

通过真值表和对应最小项, 可以得到:

$$
\begin{align}
S_i &= \overline{A_i}\ \overline{B_i}\ C_{i-1} +
\overline{A_i}\ B_i\ \overline{C_{i-1}} +
A_i\ \overline{B_i}\ \overline{C_{i-1}} +
A_i\ B_i\ C_{i-1} \\
C_{i} &= \overline{A_i}\ B_i\ C_{i-1} + A_i\ \overline{B_i}\ C_{i-1} + A_i\ B_i\ \overline{C_{i-1}} + A_i\ B_i\ C_{i-1} \\
&=A_iB_i + C_{i-1}(A_i+B_i)
\end{align}
$$

分别可以简化为:

$$
\begin{align}
S_i &= A_i \oplus B_i \oplus C_{i-1} \\
C_i &= A_iB_i + C_{i-1}(A_i\oplus B_i)
\end{align}
$$

可以观察到, 进位 $C_i$ 由两部分组成, 其中 $A_iB_i$ 与低位进位无关, 记作 $d_i$ , $C_{i-1}(A_i+B_i)$ 与低位进位有关.
称 $A_i+B_i$ 为传递条件, 记作 $t_i$ .

$$
C_i = d_i + t_iC_{i-1}
$$


### 行波进位加法器

<font color=red><b>行波进位加法器</b></font> (RCA) 是将每个全加器的输出进位作为下个全加器的输入进位:

<p align="central">
<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/5/5d/4-bit_ripple_carry_adder.svg/1920px-4-bit_ripple_carry_adder.svg.png" width="80%">
</p>

行波进位加法器可以在一个时钟周期内得到结果, 但计算过程中, 需要进位像涟漪一样从低位输出传递到高位.
在进位传递的过程中, 加法器的输出结果会跳变. 直到传递结束后, 数据稳定, 此时才能得到正确的结果.
瞬态会造成额外功耗, 也限制了电路的最高工作频率.


### 跳跃进位加法器

<font color=red><b>跳跃进位加法器</b></font> (CSkA) 也称为**进位旁路加法器** (Carry-Bypass Adder). 

<p align="central">
<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/3/31/BCSAdder16Bit.svg/1920px-BCSAdder16Bit.svg.png" width="100%">
</p>

其设计核心思想为: 在最坏情况 (长串传播) 出现时, 找到一条捷径, 让进位跳过中间的整块加法器, 而不是像涟漪一样传递.

跳跃加法器是对 RCA 的改进, 将整个 $N$ 位加法器分成若干小块, 在每个快上增加一个特殊的跳跃逻辑 (Skip Logic).

定义一个**进位传播项** $P_i = A_i\oplus B_i$ , 其含义为:

$$
P_i=1\iff A和B中有且仅有1个1
$$

即 $A=1,B=0$ 或 $A=0,B=1$ . 该情况下, $A+B$ 本身不会产生进位, 但会将低位进位忠实地传递下去, 即此时 $C_i = C_{i-1}$ .

对于一个 $k$ 位宽的区块, 设定一个组传播项 $P_{Group}$ , 定义为:

$$
P_{Group} = \prod_{i}^{i+k-1}P_i = P_i\cdot P_{i+1} \cdot P_{i+2} \cdot \cdots \cdot P_{i+k-1}
$$

即 $P_{Group}$ 位一个 $k$ 输入的与门输出. 其意义为: 当 $P_{Group}=1$ , 意味着区块内的所有 $k$ 位加法器都在等待低位进位, 它们都会忠实地将低位进位输出到高位, 而不会改变.

综上, 使用一个二选一多路选择器 (MUX) 来实现进位选择:
- 若 $P_{Group}=1$ , 跳跃条件成立, 则 MUX 直接将区块的进位输入 $C_{in}$ 作为 $C_{out}$ 输出.
- 若 $P_{Group} = 0$ , 跳跃条件不成立, 则 MUX 选择区块内的实际 RCA 进位输出.

其实现的效果为, 当跳跃条件成立时, 绕过区块内部 $k$ 级的全部延迟, 直接将结果输出到下一区块.


### 进位选择加法器

<font color=red><b>进位选择加法器</b></font> (CSA) 是一种更激进, 更快速的提速方法.

<p align="central">
<img src="https://upload.wikimedia.org/wikipedia/en/3/36/Carry-select-adder-fixed-size.png" width="100%">
</p>

其核心思想为: 与其等待低位进位的到来, 不如提前计算出所有可能的情况, 然后用真正的 $C_{in}$ 来选择正确的结果.

进位选择加法器也将整个 $N$ 位加法器分成若干区块, 在每个区块内部, 放置两套完整的加法电路, 通常是行波进位加法器:
- 电路 0 : 假定该区块的进位输入 $C_{in}=0$ , 输出 $S_0$ 和 $C_{out0}$ .
- 电路 1 : 假定该区块的进位输入 $C_{in}=1$ , 输出 $S_1$ 和 $C_{out1}$ .

两套电路并行计算, 同时工作, 而不需要等待来自低位的进位.

当低位区块计算出的实际进位 $C_{in}$ 最终到达时, 用作多路选择器 (MUX) 的选择控制信号:
- 若 $C_{in} = 0$ , MUX 选择 $S_0$ 和 $C_{out0}$ .
- 若 $C_{in} = 1$ , MUX 选择 $S_1$ 和 $C_{out1}$ .

进位选择加法器的延迟不是总位数 $N$ 的线性关系, 而取决于单个区块 RCA 的延迟, 以及最终 MUX 的延迟, MUX 的延迟很低, 因此相较于 RCA 有很大的速度提升.


### 超前进位加法器

<font color=red><b>超前进位加法器</b></font> (Carry-Lookahead Adder, CLA) 是加法器设计中理论速度最高的. 

<p align="central">
<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/0/04/4-bit_carry_lookahead_adder.svg/1280px-4-bit_carry_lookahead_adder.svg.png" width="80%">
</p>

其核心思想为: 在进行加法运算的同时, 超前计算出每一位可能产生的进位信号. 通过引入两个关键的中间变量来实现:
- 进位生成信号 $G_i$
- 进位传输信号 $P_i$

进位传输信号 $P_i$ 表示若第 $i$ 位有输入进位 $C_{i-1}$ , 则该位会忠实地将其输出到 $C_i$ :

$$
P_{i} = A_i\oplus B_i
$$

进位生成信号 $G_i$ 表示第 $i$ 位会无条件地生成一个输出进位 $C_{i}$ , 不依赖低位的输入进位 $C_{i-1}$ :

$$
G_i = A_i \cdot B_i
$$

由推导, 本位和 $S_i$ 的表达式为:

$$
\begin{align}
S_i &= A_i \oplus B_i \oplus C_{i-1} \\
&= P_i \oplus C_{i-1}
\end{align}
$$

本位输出进位 $C_i$ 的表达式通过如下逻辑获得:  
本位输出进位 $C_i$ 取决于两种情况:
- 第 $i$ 位自身产生进位 $G_i$ 
- 第 $i$ 位传输了低位传来的进位 $P_i \cdot C_{i-1}$ 

即:

$$
C_i = G_i + P_i \cdot C_{i-1}
$$

将 $C_{-1}$ 视为初始进位 $C_{in}$ , 则有:

$$
\begin{array}{|c|c|}
\hline
& 原式 & 展开式 \\
\hline
第 0 位进位 & C_0 = G_0 + P_0 \cdot C_{-1} & C_0 = G_0+P_0 \cdot C_{-1} \\
\hline
第 1 位进位 & C_1 = G_1 + P_1 \cdot C_{0} & C_1 = G_1​+P_1​G_0​+P_1 ​P_0​ C_{−1}​ \\
\hline
第 2 位进位 & C_2 = G_2 + P_2 \cdot C_{1} & C_2 = G_2 + P_2G_1 + P_2P_1G_0 + P_2P_1P_0C_{-1} \\
\hline
第 3 位进位 & C_3 = G_3 + P_3 \cdot C_{2} & C_3 = G_3 + P_3G_2 + P_3P_2G_1 + P_3P_2P_1G_0 + P_3P_2P_1P_0C_{-1} \\
\hline
\end{array}
$$

例: 

> 计算 $\texttt{1011+0101}$

解:

- $A_3A_2A_1A_0 = \texttt{1011}$
- $B_3B_2B_1B_0 = \texttt{0101}$
- $C_{-1}=0$

$$
\begin{array}{|c|c|}
\hline
i & A_i & B_i & P_i=A_i\oplus B_i & G_i = A_i \cdot B_i \\
\hline
0 & 1 & 1 & 0 & 1 \\
\hline
1 & 1 & 0 & 1 & 0 \\
\hline
2 & 0 & 1 & 1 & 0 \\
\hline
3 & 1 & 0 & 1 & 0 \\
\hline
\end{array}
$$

$$
\begin{align}
C_3 &= G_3 + P_3G_2 + P_3P_2G_1 + P_3P_2P_1G_0 + P_3P_2P_1P_0C_{-1}\\
&=0+1\cdot0+1\cdot1\cdot0+1\cdot1\cdot1\cdot1+1\cdot1\cdot1\cdot0\cdot0 \\
&=1
\end{align}
$$

$$
\begin{array}{l}
S_0 = P_0 \oplus C_{-1} = 0\oplus0 = 0 \\
S_1 = P_1 \oplus C_0 = 1\oplus1 = 0 \\
S_2 = P_2 \oplus C_1 = 1\oplus1 = 0 \\
S_3 = P_3 \oplus C_2 = 1\oplus1 = 0 \\
\end{array}
$$

最终和为 $C_3S_3S_2S_1S_0 = \texttt{10000}$ .

超前进位加法器的进位不是通过串行计算得到的, 因此速度极快, 但随着位数增多, 其展开电路规模也不断增大, 导致生产困难.

超前进位加法器的位数受<font color=red><b>最大扇入数</b></font> (Maximum Fat-in) 限制. 最大扇入数指的是一个逻辑门, 如 AND, OR, NAND, NOR 等, 能够接受的最大输入信号的数量. 
实际逻辑电路生产中扇入数受如下因素影响:
- 晶体管数量限制: 一个 N 输入的 CMOS 与非门需要 N 对晶体管.
- 延迟限制: 输入增多, 门电路内部等效电阻电容会增大, 信号传输速度降低.
- 驱动能力/噪声限制: 输入增多会降低门的噪声容限, 降低可靠性.
通常最大扇入数限制在 4~5 .

由于最大扇入数限制, CLA 实际需要通过分层实现.

超前进位加法器的计算时间增长相对位数的正常呈对数关系 $O(\log N)$ (实际由 $O(1)$ 恶化) . 其中:
- $P_i$ 和 $G_i$ 都是由 $A_i$ 和 $B_i$ 在一个逻辑门延迟内并行计算得到的.
- $C_i$ 是由 $P_k$ 和 $G_k$ 在两级 AND-OR 逻辑门内并行计算得到的.

分层结构就是将大型的 $N$ 位进位加法器分拆分成更小更易于管理的结构, 可以克服扇入数限制, 保持对数级的速度优势.

